uuid: 00b00c92-75d1-4179-883a-48a042978f8b
projectId: whatsapp-gateway-saas
createdAt: '2025-11-18T02:21:17.681Z'
gitCommitMsg: |-
  fix(tests): Resolve initialization race condition and TSC errors
  - Made the `ensureTestEnvironment` function idempotent to prevent re-running
    the setup process.
  - Re-added `ensureTestEnvironment` call to the `setup` helper, making it
    robust and removing the implicit dependency on global setup execution order.
    This fixes the runtime error "Test environment is not initialized".
  - Added types to `child_process` event handlers in `test-setup.ts` to fix
    implicit `any` TSC errors.
  - Added `import {} from 'bun:test'` to `tests/setup.ts` to bring Bun's
    global test types into scope, fixing `beforeAll`/`afterAll` TSC errors.
promptSummary: >-
  The user is reporting test failures due to an initialization order issue and
  TypeScript compiler errors. I need to fix both.
reasoning:
  - >-
    You've run into a classic test initialization race condition, and some
    TypeScript type-scoping issues. My previous refactoring was a step in the
    right direction but made the test setup too dependent on a specific
    execution order, which is brittle.
  - >-
    I'll now make the test setup more robust to fix the runtime errors and also
    resolve the TypeScript compiler errors.
  - '### Step 1: Fix Test Initialization Order'
  - >-
    The error `Test environment is not initialized` happens because the
    test-specific `beforeAll` hook runs before the global setup has a chance to
    complete. I will fix this by making the setup process idempotent (safe to
    run multiple times) and ensuring it runs before anything else needs it.
  - >-
    First, I'll update `test-setup.ts` to prevent the setup from running more
    than once.
  - >-
    Next, I'll restore the call to `ensureTestEnvironment()` in
    `helpers/setup.ts`. Because the function is now idempotent, it's safe to
    call it here, which guarantees the environment is ready before any test
    needs it.
  - '### Step 2: Fix TypeScript Compiler Errors'
  - >-
    The TypeScript errors are because the global `setup.ts` file doesn't have
    the Bun test types in its scope. I will add an import to fix this. I've also
    added types for the child process event handlers in `test-setup.ts` in the
    previous step, which resolves the "implicit any" errors.
  - >-
    These changes will resolve both the runtime test failures and the TypeScript
    compilation errors, resulting in a stable and robust test suite.
  - '---'
operations:
  - type: write
    path: gateway/tests/utils/test-setup.ts
    content: |+
      --- gateway/tests/utils/test-setup.ts
      +++ gateway/tests/utils/test-setup.ts
      @@ -26,6 +26,9 @@
          * Ensures the test environment is properly set up
          */
         public async ensureTestEnvironment(): Promise<TestEnvironment> {
      +    if (this.env) {
      +      return this.env;
      +    }
           console.log('üîß Setting up test environment...');
       
           // Set up environment variables
      @@ -250,7 +253,7 @@
               stdio: 'pipe'
             });
       
      -      generateCmd.on('close', (code) => {
      +      generateCmd.on('close', (code: number | null) => {
               if (code === 0) {
                 console.log('‚úÖ Migrations generated');
       
      @@ -260,7 +263,7 @@
                   stdio: 'pipe'
                 });
       
      -          migrateCmd.on('close', (code) => {
      +          migrateCmd.on('close', (code: number | null) => {
                   if (code === 0) {
                     console.log('‚úÖ Migrations applied successfully');
                     resolve();

    patchStrategy: standard-diff
  - type: write
    path: gateway/tests/helpers/setup.ts
    content: >+
      --- gateway/tests/helpers/setup.ts

      +++ gateway/tests/helpers/setup.ts

      @@ -31,9 +31,10 @@
        * @returns An object with the server URL and the created user/node entities.
        */
       export const setup = async () => {
      -  // The global beforeAll in setup.ts calls ensureTestEnvironment.

      -  // We retrieve the config here to ensure it's fully initialized.

      -  const env = testSetup.getEnvironment();

      +  // Ensure the environment is ready. This is idempotent and safe to
      call.

      +  await testSetup.ensureTestEnvironment();

      +

      +  const env = testSetup.getEnvironment(); // This will now succeed.
         TEST_USER_API_KEY = env.API_SECRET;
         TEST_INTERNAL_API_SECRET = env.INTERNAL_API_SECRET;
       

    patchStrategy: standard-diff
  - type: write
    path: gateway/tests/setup.ts
    content: |+
      --- gateway/tests/setup.ts
      +++ gateway/tests/setup.ts
      @@ -1,3 +1,4 @@
      +import {} from 'bun:test'; // Import to load bun test types for globals
       import { testSetup } from './utils/test-setup';
       
       // Global setup for all tests

    patchStrategy: standard-diff
snapshot:
  gateway/tests/helpers/setup.ts: >-
    import { drizzle, type PostgresJsDatabase } from 'drizzle-orm/postgres-js';

    import postgres, { type Sql } from 'postgres';

    import { getDockerClientForNode, type ContainerInfo } from
    '../../src/docker.client';

    import * as schema from '../../../drizzle/schema';

    import { createApp } from '../../src/app';

    import { testSetup } from '../utils/test-setup';


    // --- Types ---

    export type User = typeof schema.users.$inferSelect;

    export type Node = typeof schema.nodes.$inferSelect;

    export type Instance = typeof schema.instances.$inferSelect;


    // --- DB Connection ---

    // These are initialized in setup() to prevent connection attempts before
    the test DB is ready.

    let client: Sql;

    export let db: PostgresJsDatabase<typeof schema>;


    // --- Test Constants (initialized in setup) ---

    export let TEST_USER_API_KEY: string;

    export let TEST_INTERNAL_API_SECRET: string;

    export const TEST_NODE_DOCKER_HOST = process.env.TEST_DOCKER_HOST ||
    'unix:///var/run/docker.sock';

    export const TEST_NODE_PUBLIC_HOST = 'localhost';


    const docker = getDockerClientForNode({ dockerHost: TEST_NODE_DOCKER_HOST
    });



    /**
     * Sets up the test environment:
     * 1. Establishes DB connection.
     * 2. Starts the API server on a random available port.
     * 3. Cleans and seeds the database with a test user and a test node.
     * @returns An object with the server URL and the created user/node entities.
     */
    export const setup = async () => {
      // The global beforeAll in setup.ts calls ensureTestEnvironment.
      // We retrieve the config here to ensure it's fully initialized.
      const env = testSetup.getEnvironment();
      TEST_USER_API_KEY = env.API_SECRET;
      TEST_INTERNAL_API_SECRET = env.INTERNAL_API_SECRET;

      // 1. Establish DB connection
      // Use the connection string from the now-initialized environment
      const connectionString = env.DATABASE_URL;
      if (!connectionString) {
        throw new Error("DATABASE_URL is not set. Please create a .env.test file.");
      }
      client = postgres(connectionString);
      db = drizzle(client, { schema });

      // 2. Create app with database and start server on a random available port
      const app = createApp(db);
      await app.listen(0);

      // 3. Clean database before seeding to ensure a fresh state.
      await db.delete(schema.instanceState);
      await db.delete(schema.instances);
      await db.delete(schema.users);
      await db.delete(schema.nodes);

      const [testUser] = await db.insert(schema.users).values({
        email: `test-${Date.now()}@example.com`,
        apiKey: TEST_USER_API_KEY,
      }).returning();

      const [testNode] = await db.insert(schema.nodes).values({
        name: 'test-node-1',
        dockerHost: TEST_NODE_DOCKER_HOST,
        publicHost: TEST_NODE_PUBLIC_HOST,
      }).returning();

      return {
        serverUrl: `http://localhost:${app.server?.port}`,
        user: testUser,
        node: testNode,
        app, // Return app instance for teardown
      };
    };


    /**
     * Tears down the test environment:
     * 1. Stops the API server.
     * 2. Closes the database connection.
     * 3. Cleans up test database and environment.
     */
    export const teardown = async (app: any) => {
      await app.stop();
      if (client) {
        await client.end({ timeout: 5 });
      }
      // Clean up the test environment (but not the database container)
      await testSetup.cleanup();
    };


    /**
     * Removes all instance-related records from the database.
     */
    export const cleanupDb = async () => {
        // db is guaranteed to be initialized by setup() in beforeAll
        await db.delete(schema.instanceState);
        await db.delete(schema.instances);
    };


    /**
     * Helper to create a test instance in the database.
     */
    export async function createTestInstance(
        db: PostgresJsDatabase<typeof schema>,
        user: User,
        node: Node,
        overrides: Partial<Omit<Instance, 'id' | 'userId' | 'nodeId'>> = {}
    ): Promise<Instance> {
        const [instance] = await db.insert(schema.instances).values({
            nodeId: node.id,
            userId: user.id,
            phoneNumber: '9876543210',
            provider: 'whatsmeow',
            status: 'running', // Default to running for most API tests
            ...overrides,
        }).returning();
        return instance;
    }


    /**
     * Finds and removes all Docker containers created by the tests.
     */
    export const cleanupContainers = async () => {
        const containers = await docker.listContainers({
            all: true,
            filters: { label: [`whatsapp-gateway-saas.instance-id`] }
        });

        for (const containerInfo of containers) {
            console.log(`Cleaning up test container: ${containerInfo.Id}`);
            try {
                await docker.stopContainer(containerInfo.Id, { t: 5 });
            } catch (e: any) {
                // Ignore if already stopped (304) or not found (404)
                if (e.statusCode !== 304 && e.statusCode !== 404) console.error(e);
            }
            try {
                await docker.removeContainer(containerInfo.Id);
            } catch (e: any) {
                 // Ignore if not found (404)
                if (e.statusCode !== 404) console.error(e);
            }
        }
    };


    /**
     * Test helper to find a container by its instance ID label.
     * @param instanceId The ID of the instance.
     * @returns ContainerInfo if found, otherwise undefined.
     */
    export async function findContainerByInstanceId(instanceId: number):
    Promise<ContainerInfo | undefined> {
        const containers = await docker.listContainers({
            all: true,
            filters: { label: [`whatsapp-gateway-saas.instance-id=${instanceId}`] }
        });
        return containers[0];
    }
  gateway/tests/utils/test-setup.ts: |-
    import { spawn } from 'child_process';
    import { existsSync, mkdirSync, writeFileSync, readFileSync } from 'fs';
    import { join } from 'path';
    import { drizzle } from 'drizzle-orm/postgres-js';
    import postgres, { type Sql } from 'postgres';
    import * as schema from '../../../drizzle/schema';
    import { promises as fs } from 'fs';

    export interface TestEnvironment {
      DATABASE_URL: string;
      INTERNAL_API_SECRET: string;
      API_SECRET: string;
      GATEWAY_URL: string;
      NODE_ENV: string;
    }

    export class TestSetup {
      private static instance: TestSetup;
      private dbConnection: Sql | null = null;
      private db: any = null;
      private envFileCreated = false;
      private migrationsRun = false;
      private env: TestEnvironment | null = null;

      private constructor() {}

      public static getInstance(): TestSetup {
        if (!TestSetup.instance) {
          TestSetup.instance = new TestSetup();
        }
        return TestSetup.instance;
      }

      public getEnvironment(): TestEnvironment {
        if (!this.env) {
          throw new Error('Test environment is not initialized. Call ensureTestEnvironment() first.');
        }
        return this.env;
      }

      /**
       * Ensures the test environment is properly set up
       */
      public async ensureTestEnvironment(): Promise<TestEnvironment> {
        console.log('üîß Setting up test environment...');

        // Set up environment variables
        const env = await this.setupEnvironment();

        // Start test database if needed
        await this.ensureTestDatabase();

        // Set up database schema
        await this.ensureDatabaseSchema();

        console.log('‚úÖ Test environment ready');
        return env;
      }

      /**
       * Sets up the test environment variables
       */
      private async setupEnvironment(): Promise<TestEnvironment> {
        const env: TestEnvironment = {
          DATABASE_URL: 'postgresql://test_user:test_password@localhost:5433/test_db',
          INTERNAL_API_SECRET: 'test-internal-secret-for-ci',
          API_SECRET: 'test-api-key-secret-for-ci',
          GATEWAY_URL: 'http://localhost:3000',
          NODE_ENV: 'test'
        };

        // Set environment variables
        Object.entries(env).forEach(([key, value]) => {
          process.env[key] = value;
        });

        // Store for later retrieval
        this.env = env;

        // Create .env.test file if it doesn't exist
        const gatewayDir = join(process.cwd());
        const envTestPath = join(gatewayDir, '.env.test');

        if (!existsSync(envTestPath)) {
          const envContent = Object.entries(env)
            .map(([key, value]) => `${key}=${value}`)
            .join('\n');

          await fs.writeFile(envTestPath, envContent);
          this.envFileCreated = true;
          console.log('üìù Created .env.test file');
        }

        return env;
      }

      /**
       * Ensures test database is running and accessible
       */
      private async ensureTestDatabase(): Promise<void> {
        console.log('üóÑÔ∏è  Checking test database...');

        try {
          // Try to connect to the database
          const client = postgres(process.env.DATABASE_URL!, { timeout: 5000 });
          await client`SELECT 1`;
          await client.end();
          console.log('‚úÖ Test database is accessible');
          return;
        } catch (error) {
          console.log('‚ö†Ô∏è  Test database not accessible, starting it...');
          await this.startTestDatabase();
        }
      }

      /**
       * Starts the test database using Docker
       */
      private async startTestDatabase(): Promise<void> {
        return new Promise((resolve, reject) => {
          console.log('üê≥ Starting test database container...');

          // Stop existing container if it exists
          const stopCmd = spawn('docker', [
            'stop', 'whatsapp-gateway-saas-test-db'
          ], { stdio: 'pipe' });

          stopCmd.on('close', () => {
            const rmCmd = spawn('docker', [
              'rm', 'whatsapp-gateway-saas-test-db'
            ], { stdio: 'pipe' });

            rmCmd.on('close', () => {
              const runCmd = spawn('docker', [
                'run', '-d',
                '--name', 'whatsapp-gateway-saas-test-db',
                '-e', 'POSTGRES_USER=test_user',
                '-e', 'POSTGRES_PASSWORD=test_password',
                '-e', 'POSTGRES_DB=test_db',
                '-p', '5433:5432',
                '--restart', 'unless-stopped',
                'postgres:16-alpine'
              ], { stdio: 'pipe' });

              runCmd.on('close', (code) => {
                if (code === 0) {
                  console.log('‚úÖ Test database container started');
                  this.waitForDatabase().then(resolve).catch(reject);
                } else {
                  reject(new Error('Failed to start test database container'));
                }
              });

              runCmd.on('error', reject);
            });

            rmCmd.on('error', (error) => {
              // Container might not exist, which is fine
              console.log('‚ÑπÔ∏è  No existing container to remove');
              const runCmd = spawn('docker', [
                'run', '-d',
                '--name', 'whatsapp-gateway-saas-test-db',
                '-e', 'POSTGRES_USER=test_user',
                '-e', 'POSTGRES_PASSWORD=test_password',
                '-e', 'POSTGRES_DB=test_db',
                '-p', '5433:5432',
                '--restart', 'unless-stopped',
                'postgres:16-alpine'
              ], { stdio: 'pipe' });

              runCmd.on('close', (code) => {
                if (code === 0) {
                  console.log('‚úÖ Test database container started');
                  this.waitForDatabase().then(resolve).catch(reject);
                } else {
                  reject(new Error('Failed to start test database container'));
                }
              });

              runCmd.on('error', reject);
            });
          });

          stopCmd.on('error', (error) => {
            // Container might not exist, which is fine
            console.log('‚ÑπÔ∏è  No existing container to stop');
          });
        });
      }

      /**
       * Waits for the database to be ready
       */
      private async waitForDatabase(): Promise<void> {
        console.log('‚è≥ Waiting for database to be ready...');

        for (let i = 0; i < 30; i++) {
          try {
            const client = postgres(process.env.DATABASE_URL!, { timeout: 5000 });
            await client`SELECT 1`;
            await client.end();
            console.log('‚úÖ Database is ready');
            return;
          } catch (error) {
            await new Promise(resolve => setTimeout(resolve, 1000));
          }
        }

        throw new Error('Database failed to become ready within 30 seconds');
      }

      /**
       * Ensures the database schema is set up
       */
      private async ensureDatabaseSchema(): Promise<void> {
        if (this.migrationsRun) {
          return;
        }

        console.log('üóÉÔ∏è  Setting up database schema...');

        try {
          // Try to connect and check if tables exist
          await this.connectToDatabase();

          // Check if tables exist by trying to query one of them
          try {
            await this.db.query.users.findFirst();
            console.log('‚úÖ Database schema already exists');
            this.migrationsRun = true;
            return;
          } catch (error) {
            // Tables don't exist, need to run migrations
            console.log('üîÑ Database schema needs to be created');
          }

          // Run migrations
          await this.runMigrations();
          this.migrationsRun = true;
          console.log('‚úÖ Database schema created successfully');

        } catch (error) {
          console.error('‚ùå Failed to set up database schema:', error);
          throw error;
        }
      }

      /**
       * Connects to the database
       */
      private async connectToDatabase(): Promise<void> {
        if (this.dbConnection) {
          return;
        }

        this.dbConnection = postgres(process.env.DATABASE_URL!);
        this.db = drizzle(this.dbConnection, { schema });
      }

      /**
       * Runs database migrations
       */
      private async runMigrations(): Promise<void> {
        console.log('üì¶ Running database migrations...');

        return new Promise((resolve, reject) => {
          const { spawn } = require('child_process');

          // First, generate migrations if they don't exist
          const generateCmd = spawn('npx', ['drizzle-kit', 'generate'], {
            cwd: join(process.cwd(), '..'),
            stdio: 'pipe'
          });

          generateCmd.on('close', (code) => {
            if (code === 0) {
              console.log('‚úÖ Migrations generated');

              // Then run the migrations
              const migrateCmd = spawn('npx', ['drizzle-kit', 'migrate'], {
                cwd: join(process.cwd(), '..'),
                stdio: 'pipe'
              });

              migrateCmd.on('close', (code) => {
                if (code === 0) {
                  console.log('‚úÖ Migrations applied successfully');
                  resolve();
                } else {
                  reject(new Error('Migration failed'));
                }
              });

              migrateCmd.on('error', reject);
            } else {
              reject(new Error('Migration generation failed'));
            }
          });

          generateCmd.on('error', reject);
        });
      }

      /**
       * Gets the database connection for tests
       */
      public async getDb() {
        if (!this.db) {
          await this.connectToDatabase();
        }
        return this.db;
      }

      /**
       * Cleans up the test environment
       */
      public async cleanup(): Promise<void> {
        console.log('üßπ Cleaning up test environment...');

        if (this.dbConnection) {
          try {
            await this.dbConnection.end({ timeout: 5 });
            this.dbConnection = null;
            this.db = null;
          } catch (error) {
            console.warn('‚ö†Ô∏è  Failed to close database connection:', error);
          }
        }

        if (this.envFileCreated) {
          try {
            const gatewayDir = join(process.cwd());
            const envTestPath = join(gatewayDir, '.env.test');
            await fs.unlink(envTestPath);
            console.log('üóëÔ∏è  Removed .env.test file');
            this.envFileCreated = false; // Reset for next test run
          } catch (error) {
            console.warn('‚ö†Ô∏è  Failed to remove .env.test file:', error);
          }
        }

        // Only clean up database container if explicitly requested or no other tests are running
        // This prevents cleanup conflicts when multiple test files are running
      }

      /**
       * Force cleanup of database container (for explicit cleanup only)
       */
      public async forceCleanup(): Promise<void> {
        console.log('üßπ Force cleaning up test environment...');

        if (this.dbConnection) {
          try {
            await this.dbConnection.end({ timeout: 5 });
            this.dbConnection = null;
            this.db = null;
          } catch (error) {
            console.warn('‚ö†Ô∏è  Failed to close database connection:', error);
          }
        }

        if (this.envFileCreated) {
          try {
            const gatewayDir = join(process.cwd());
            const envTestPath = join(gatewayDir, '.env.test');
            await fs.unlink(envTestPath);
            console.log('üóëÔ∏è  Removed .env.test file');
          } catch (error) {
            console.warn('‚ö†Ô∏è  Failed to remove .env.test file:', error);
          }
        }

        // Stop test database container
        try {
          const { spawn } = require('child_process');
          const stopCmd = spawn('docker', ['stop', 'whatsapp-gateway-saas-test-db'], { stdio: 'pipe' });

          stopCmd.on('close', () => {
            const rmCmd = spawn('docker', ['rm', 'whatsapp-gateway-saas-test-db'], { stdio: 'pipe' });
            rmCmd.on('close', () => {
              console.log('‚úÖ Test database container stopped and removed');
            });
          });
        } catch (error) {
          console.warn('‚ö†Ô∏è  Failed to clean up test database container:', error);
        }
      }
    }

    // Export singleton instance
    export const testSetup = TestSetup.getInstance();
  gateway/tests/setup.ts: |-
    import { testSetup } from './utils/test-setup';

    // Global setup for all tests
    beforeAll(async () => {
      console.log('üöÄ Setting up global test environment...');
      await testSetup.ensureTestEnvironment();
    }, 60000);

    // Global cleanup after all tests
    afterAll(async () => {
      console.log('üßπ Cleaning up global test environment...');
      await testSetup.cleanup();
    }, 30000);

    // Handle unhandled promise rejections in tests
    process.on('unhandledRejection', (reason, promise) => {
      console.error('Unhandled Rejection at:', promise, 'reason:', reason);
    });

    // Handle uncaught exceptions in tests
    process.on('uncaughtException', (error) => {
      console.error('Uncaught Exception:', error);
      process.exit(1);
    });
approved: true
linesAdded: 10
linesRemoved: 5
linesDifference: 15
gitCommittedAt: '2025-11-18T02:21:36.417Z'
status: committed
id: 24
