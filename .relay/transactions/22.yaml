uuid: 48ec90b2-4876-4d51-8631-f1f3a2862ed7
projectId: whatsapp-gateway-saas
createdAt: '2025-11-18T01:56:13.490Z'
gitCommitMsg: >-
  fix(tests): defer DB connection in e2e setup to fix race condition

  The E2E tests were failing with `ECONNREFUSED` because the database client was
  being initialized at the module-level in `setup.ts`. This created a race
  condition where Bun's test runner could load the module and attempt a
  connection before the `pretest` script had finished starting the PostgreSQL
  container.

  This commit fixes the issue by moving the database connection and client
  initialization logic inside the `setup()` function, which is guaranteed to run
  in `beforeAll` after the `pretest` script is complete. This ensures the
  database is ready before any connection is attempted.
promptSummary: >-
  The user's E2E tests are failing with ECONNREFUSED after setting up a test
  database. I've diagnosed a race condition and am fixing it.
reasoning:
  - >-
    It looks like the E2E tests are failing because of a race condition. The
    test helper file (`gateway/tests/helpers/setup.ts`) was initializing the
    database connection as soon as the file was loaded. However, Bun's test
    runner can load the test files *before* the `pretest` script (which starts
    the database container) has fully completed. This means the test code was
    trying to connect to a database that wasn't ready yet, causing the
    `ECONNREFUSED` error.
  - >-
    To fix this, I'll modify `gateway/tests/helpers/setup.ts` to defer the
    database connection. Instead of connecting at the module level, the
    connection will be established inside the `setup()` function, which is
    called by `beforeAll`. This ensures the database container is up and running
    before any connection is attempted.
  - 'Here''s the change:'
operations:
  - type: write
    path: gateway/tests/helpers/setup.ts
    content: >+
      --- gateway/tests/helpers/setup.ts

      +++ gateway/tests/helpers/setup.ts

      @@ -1,21 +1,23 @@

      -import { drizzle } from 'drizzle-orm/postgres-js';

      -import postgres from 'postgres';

      +import { drizzle, type PostgresJsDatabase } from
      'drizzle-orm/postgres-js';

      +import postgres, { type Sql } from 'postgres';
       import { getDockerClientForNode, type ContainerInfo } from '../../src/docker.client';
       import * as schema from '../../../drizzle/schema';
       import { app } from '../../src/index';
       
       // --- Types ---
       export type User = typeof schema.users.$inferSelect;
       export type Node = typeof schema.nodes.$inferSelect;
       export type Instance = typeof schema.instances.$inferSelect;
       
       // --- DB Connection ---
      -const connectionString = process.env.DATABASE_URL;

      -if (!connectionString) {

      -  throw new Error("DATABASE_URL is not set. Please create a .env file for
      testing.");

      -}

      -const client = postgres(connectionString);

      -export const db = drizzle(client, { schema });

      +// These are initialized in setup() to prevent connection attempts before
      the test DB is ready.

      +let client: Sql;

      +export let db: PostgresJsDatabase<typeof schema>;
       
       // --- Docker Client ---
       // --- Test Constants ---
      @@ -29,18 +31,29 @@
       
       /**
        * Sets up the test environment:
      - * 1. Starts the API server on a random available port.

      - * 2. Cleans and seeds the database with a test user and a test node.

      + * 1. Establishes DB connection.

      + * 2. Starts the API server on a random available port.

      + * 3. Cleans and seeds the database with a test user and a test node.
        * @returns An object with the server URL and the created user/node entities.
        */
       export const setup = async () => {
      -  // Start server on a random available port by passing 0.

      +  // 1. Establish DB connection

      +  const connectionString = process.env.DATABASE_URL;

      +  if (!connectionString) {

      +    throw new Error("DATABASE_URL is not set. Please create a .env.test
      file.");

      +  }

      +  client = postgres(connectionString);

      +  db = drizzle(client, { schema });

      +

      +  // 2. Start server on a random available port by passing 0.
         await app.listen(0);
       
      -  // Clean database before seeding to ensure a fresh state.

      +  // 3. Clean database before seeding to ensure a fresh state.
         await db.delete(schema.instanceState);
         await db.delete(schema.instances);
         await db.delete(schema.users);
         await db.delete(schema.nodes);
         
         const [testUser] = await db.insert(schema.users).values({
           email: `test-${Date.now()}@example.com`,
      @@ -65,13 +78,17 @@
        */
       export const teardown = async () => {
         await app.stop();
      -  await client.end({ timeout: 5 });

      +  if (client) {

      +    await client.end({ timeout: 5 });

      +  }
       };
       
       /**
        * Removes all instance-related records from the database.
        */
       export const cleanupDb = async () => {
      +    // db is guaranteed to be initialized by setup() in beforeAll
           await db.delete(schema.instanceState);
           await db.delete(schema.instances);
       };

    patchStrategy: standard-diff
snapshot:
  gateway/tests/helpers/setup.ts: >-
    import { drizzle } from 'drizzle-orm/postgres-js';

    import postgres from 'postgres';

    import { getDockerClientForNode, type ContainerInfo } from
    '../../src/docker.client';

    import * as schema from '../../../drizzle/schema';

    import { app } from '../../src/index';


    // --- Types ---

    export type User = typeof schema.users.$inferSelect;

    export type Node = typeof schema.nodes.$inferSelect;

    export type Instance = typeof schema.instances.$inferSelect;


    // --- DB Connection ---

    const connectionString = process.env.DATABASE_URL;

    if (!connectionString) {
      throw new Error("DATABASE_URL is not set. Please create a .env file for testing.");
    }

    const client = postgres(connectionString);

    export const db = drizzle(client, { schema });


    // --- Docker Client ---

    // --- Test Constants ---

    // Bun automatically loads .env, but we provide fallbacks.

    export const TEST_USER_API_KEY = process.env.API_SECRET ||
    'test-api-key-secret-for-ci';

    export const TEST_INTERNAL_API_SECRET = process.env.INTERNAL_API_SECRET ||
    'test-internal-secret-for-ci';

    export const TEST_NODE_DOCKER_HOST = process.env.TEST_DOCKER_HOST ||
    'unix:///var/run/docker.sock';

    export const TEST_NODE_PUBLIC_HOST = 'localhost';


    const docker = getDockerClientForNode({ dockerHost: TEST_NODE_DOCKER_HOST
    });



    /**
     * Sets up the test environment:
     * 1. Starts the API server on a random available port.
     * 2. Cleans and seeds the database with a test user and a test node.
     * @returns An object with the server URL and the created user/node entities.
     */
    export const setup = async () => {
      // Start server on a random available port by passing 0.
      await app.listen(0);

      // Clean database before seeding to ensure a fresh state.
      await db.delete(schema.instanceState);
      await db.delete(schema.instances);
      await db.delete(schema.users);
      await db.delete(schema.nodes);
      
      const [testUser] = await db.insert(schema.users).values({
        email: `test-${Date.now()}@example.com`,
        apiKey: TEST_USER_API_KEY,
      }).returning();

      const [testNode] = await db.insert(schema.nodes).values({
        name: 'test-node-1',
        dockerHost: TEST_NODE_DOCKER_HOST,
        publicHost: TEST_NODE_PUBLIC_HOST,
      }).returning();

      return {
        serverUrl: `http://localhost:${app.server?.port}`,
        user: testUser,
        node: testNode,
      };
    };


    /**
     * Tears down the test environment:
     * 1. Stops the API server.
     * 2. Closes the database connection.
     */
    export const teardown = async () => {
      await app.stop();
      await client.end({ timeout: 5 });
    };


    /**
     * Removes all instance-related records from the database.
     */
    export const cleanupDb = async () => {
        await db.delete(schema.instanceState);
        await db.delete(schema.instances);
    };


    /**
     * Finds and removes all Docker containers created by the tests.
     */
    export const cleanupContainers = async () => {
        const containers = await docker.listContainers({
            all: true,
            filters: { label: [`whatsapp-gateway-saas.instance-id`] }
        });

        for (const containerInfo of containers) {
            console.log(`Cleaning up test container: ${containerInfo.Id}`);
            try {
                await docker.stopContainer(containerInfo.Id, { t: 5 });
            } catch (e: any) {
                // Ignore if already stopped (304) or not found (404)
                if (e.statusCode !== 304 && e.statusCode !== 404) console.error(e);
            }
            try {
                await docker.removeContainer(containerInfo.Id);
            } catch (e: any) {
                 // Ignore if not found (404)
                if (e.statusCode !== 404) console.error(e);
            }
        }
    };


    /**
     * Test helper to find a container by its instance ID label.
     * @param instanceId The ID of the instance.
     * @returns ContainerInfo if found, otherwise undefined.
     */
    export async function findContainerByInstanceId(instanceId: number):
    Promise<ContainerInfo | undefined> {
        const containers = await docker.listContainers({
            all: true,
            filters: { label: [`whatsapp-gateway-saas.instance-id=${instanceId}`] }
        });
        return containers[0];
    }
approved: true
linesAdded: 22
linesRemoved: 13
linesDifference: 35
gitCommittedAt: null
status: committed
id: 22
