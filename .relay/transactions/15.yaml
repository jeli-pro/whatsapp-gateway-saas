uuid: 4d284fbe-d40b-426c-9c7f-f7d1421713d6
projectId: whatsapp-gateway-saas
createdAt: '2025-11-18T01:26:57.841Z'
gitCommitMsg: >-
  feat(testing): add test infrastructure and initial unit tests

  - Adds `bun test` scripts to root and gateway package.json files. - Configures
  gateway tsconfig to include the new `tests` directory. - Establishes the
  `tests/{unit,integration,e2e}` directory structure. - Implements unit tests
  for `parseMemory` and `sanitizeForContainerName` utility functions in
  `docker.service.ts`. - Exports the utility functions to make them testable.
promptSummary: >-
  Implement test cases based on the README.md, following specified codebase
  compliance rules. This commit covers Part 1 (Infrastructure) and Part 2 (Unit
  Tests) of the testing plan.
reasoning:
  - Executing Parts 1 and 2 of the test suite implementation plan.
  - '### Part 1: Test Infrastructure and Configuration'
  - >-
    First, I'll update the `package.json` files to include the `test` script,
    making it easy to run our test suite with `bun test`. I will also update the
    TypeScript configuration in the gateway to recognize the new `tests`
    directory.
  - >-
    Next, I'll create the required directory structure for our tests (`unit`,
    `integration`, `e2e`) inside the `gateway` workspace, along with a
    placeholder helper file for future use.
  - '### Part 2: Unit Tests'
  - >-
    To write unit tests for the utility functions in `docker.service.ts`, I
    first need to export them.
  - >-
    Now I can add the unit test file, which validates the logic for parsing
    memory strings and sanitizing container names.
operations:
  - type: write
    path: package.json
    content: |
      <<<<<<< SEARCH
        "scripts": {
          "dev": "bun --cwd gateway run dev",
          "db:generate": "drizzle-kit generate",
          "db:migrate": "drizzle-kit migrate"
        },
      =======
        "scripts": {
          "dev": "bun --cwd gateway run dev",
          "test": "bun --cwd gateway run test",
          "db:generate": "drizzle-kit generate",
          "db:migrate": "drizzle-kit migrate"
        },
      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: write
    path: gateway/package.json
    content: |
      <<<<<<< SEARCH
        "scripts": {
          "dev": "bun --watch src/index.ts",
          "lint": "eslint .",
          "typecheck": "tsc -b"
        },
      =======
        "scripts": {
          "dev": "bun --watch src/index.ts",
          "lint": "eslint .",
          "typecheck": "tsc -b",
          "test": "bun test"
        },
      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: write
    path: gateway/tsconfig.json
    content: |
      <<<<<<< SEARCH
        "include": [
          "src",
          "../drizzle/schema.ts"
        ]
      }
      =======
        "include": [
          "src",
          "../drizzle/schema.ts",
          "tests"
        ]
      }
      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: write
    path: gateway/tests/helpers/setup.ts
    content: >-
      // This file will contain setup and teardown logic for integration and E2E
      tests.

      // For now, it's a placeholder to establish the project structure.


      export const setup = () => {
          // TODO: Implement test server start
      };


      export const teardown = () => {
          // TODO: Implement test server stop and DB cleanup
      };
    patchStrategy: replace
  - type: write
    path: gateway/tests/unit/.gitkeep
    content: // This file ensures the directory is tracked by git.
    patchStrategy: replace
  - type: write
    path: gateway/tests/integration/.gitkeep
    content: // This file ensures the directory is tracked by git.
    patchStrategy: replace
  - type: write
    path: gateway/tests/e2e/.gitkeep
    content: // This file ensures the directory is tracked by git.
    patchStrategy: replace
  - type: write
    path: gateway/src/docker.service.ts
    content: |+
      --- gateway/src/docker.service.ts
      +++ gateway/src/docker.service.ts
      @@ -29,7 +29,7 @@
           provider: string;
       }
       
      -function sanitizeForContainerName(name: string): string {
      +export function sanitizeForContainerName(name: string): string {
           if (!name) return '';
           return name.toLowerCase().replace(/[^a-z0-9_.-]/g, '-').replace(/-+/g, '-');
       }
      @@ -148,7 +148,7 @@
           }
       }
       
      -function parseMemory(memoryStr: string): number {
      +export function parseMemory(memoryStr: string): number {
           if (!memoryStr) return 0; // default
           const unit = memoryStr.slice(-1).toLowerCase();
           const value = parseFloat(memoryStr.slice(0, -1));

    patchStrategy: standard-diff
  - type: write
    path: gateway/tests/unit/docker.service.test.ts
    content: >-
      import { describe, test, expect } from 'bun:test';

      import { sanitizeForContainerName, parseMemory } from
      '../../src/docker.service';


      describe('Docker Service Utilities', () => {
          describe('sanitizeForContainerName', () => {
              test('should convert to lowercase', () => {
                  expect(sanitizeForContainerName('MyContainer')).toBe('mycontainer');
              });

              test('should replace spaces with hyphens', () => {
                  expect(sanitizeForContainerName('my container name')).toBe('my-container-name');
              });

              test('should replace multiple special characters with a single hyphen', () => {
                  expect(sanitizeForContainerName('my@#$container--_name')).toBe('my-container-.-name');
              });

              test('should collapse consecutive hyphens', () => {
                  expect(sanitizeForContainerName('my---container')).toBe('my-container');
              });

              test('should handle empty string', () => {
                  expect(sanitizeForContainerName('')).toBe('');
              });

              test('should allow valid characters like dots and underscores', () => {
                  expect(sanitizeForContainerName('my_container.v1')).toBe('my_container.v1');
              });
          });

          describe('parseMemory', () => {
              test('should parse megabytes (m)', () => {
                  expect(parseMemory('512m')).toBe(512 * 1024 * 1024);
              });

              test('should parse gigabytes (g)', () => {
                  expect(parseMemory('2g')).toBe(2 * 1024 * 1024 * 1024);
              });
              
              test('should parse kilobytes (k)', () => {
                  expect(parseMemory('256k')).toBe(256 * 1024);
              });

              test('should handle uppercase units', () => {
                  expect(parseMemory('512M')).toBe(512 * 1024 * 1024);
                  expect(parseMemory('2G')).toBe(2 * 1024 * 1024 * 1024);
              });

              test('should return 0 for empty string', () => {
                  expect(parseMemory('')).toBe(0);
              });

              test('should return 0 for invalid string', () => {
                  expect(parseMemory('invalid')).toBe(0);
              });

              test('should treat number string as bytes', () => {
                  expect(parseMemory('1024')).toBe(1024);
              });
          });
      });
    patchStrategy: replace
snapshot:
  gateway/tests/helpers/setup.ts: null
  gateway/tests/unit/.gitkeep: null
  gateway/tests/integration/.gitkeep: null
  gateway/tests/e2e/.gitkeep: null
  gateway/tests/unit/docker.service.test.ts: null
  package.json: |-
    {
      "name": "whatsapp-gateway-saas",
      "version": "0.1.0",
      "private": true,
      "workspaces": [
        "gateway"
      ],
      "scripts": {
        "dev": "bun --cwd gateway run dev",
        "db:generate": "drizzle-kit generate",
        "db:migrate": "drizzle-kit migrate"
      },
      "devDependencies": {
        "drizzle-kit": "latest",
        "dotenv": "latest",
        "typescript": "latest"
      }
    }
  gateway/package.json: |-
    {
      "name": "gateway",
      "module": "src/index.ts",
      "type": "module",
      "scripts": {
        "dev": "bun --watch src/index.ts",
        "lint": "eslint .",
        "typecheck": "tsc -b"
      },
      "devDependencies": {
        "@types/dockerode": "latest",
        "@typescript-eslint/eslint-plugin": "latest",
        "@typescript-eslint/parser": "latest",
        "bun-types": "latest",
        "eslint": "latest",
        "typescript": "latest"
      },
      "peerDependencies": {
        "typescript": "^5.0.0"
      },
      "dependencies": {
        "elysia": "latest",
        "drizzle-orm": "latest",
        "postgres": "latest",
        "dockerode": "latest"
      }
    }
  gateway/src/docker.service.ts: >-
    import Dockerode from 'dockerode';

    import { URL } from 'url';


    // A simple representation of a worker node, passed from the API layer.

    export interface WorkerNode {
        id: number;
        dockerHost: string;
        publicHost: string;
    }


    function getDockerClientForNode(node: Pick<WorkerNode, 'dockerHost'>):
    Dockerode {
        if (node.dockerHost.startsWith('unix://') || node.dockerHost.startsWith('/')) {
            return new Dockerode({ socketPath: node.dockerHost.replace('unix://', '') });
        }
        if (node.dockerHost.startsWith('tcp://')) {
            const parsedUrl = new URL(node.dockerHost);
            return new Dockerode({ host: parsedUrl.hostname, port: parsedUrl.port });
        }
        // Fallback for simple host:port
        const [host, port] = node.dockerHost.split(':');
        return new Dockerode({ host, port: parseInt(port, 10) });
    }


    function getImageForProvider(provider: string): string {
        const imageMap: Record<string, string> = {
            'whatsmeow': 'jelipro/whatsapp-gateway-whatsmeow:latest',
            // 'baileys': 'some-other-image:latest',
        };
        const image = imageMap[provider];
        if (!image) {
            throw new Error(`Unsupported provider: ${provider}`);
        }
        return image;
    }


    interface CreateContainerOptions {
        instanceId: number;
        node: WorkerNode;
        name?: string | null;
        webhookUrl: string;
        cpuLimit: string;
        memoryLimit: string;
        provider: string;
    }


    function sanitizeForContainerName(name: string): string {
        if (!name) return '';
        return name.toLowerCase().replace(/[^a-z0-9_.-]/g, '-').replace(/-+/g, '-');
    }


    export async function createAndStartContainer(options:
    CreateContainerOptions) {
        const docker = getDockerClientForNode(options.node);
        const saneName = sanitizeForContainerName(options.name || '');
        const containerName = options.name 
            ? `wgs-${options.instanceId}-${saneName}`
            : `wgs-instance-${options.instanceId}`;

        const routerName = `wgs-instance-${options.instanceId}`;

        console.log(`Creating container ${containerName} for instance ${options.instanceId} on node ${options.node.publicHost}`);

        const DOCKER_IMAGE = getImageForProvider(options.provider);

        // 1. Pull the image on the target node
        await pullImage(DOCKER_IMAGE, options.node);

        const gatewayUrl = process.env.GATEWAY_URL; // Should be reachable from worker nodes
        const internalApiSecret = process.env.INTERNAL_API_SECRET;

        // 2. Create the container
        const container = await docker.createContainer({
            Image: DOCKER_IMAGE,
            name: containerName,
            Env: [
                `INSTANCE_ID=${options.instanceId}`,
                `GATEWAY_URL=${gatewayUrl}`,
                `INTERNAL_API_SECRET=${internalApiSecret}`,
                `WEBHOOK_URL=${options.webhookUrl}`,
                `PORT=8080`,
                `GOMAXPROCS=1`
            ],
            Labels: {
                'whatsapp-gateway-saas.instance-id': String(options.instanceId),
                // Traefik Labels for reverse proxying
                'traefik.enable': 'true',
                [`traefik.http.routers.${routerName}.rule`]: `Host(\`${options.node.publicHost}\`) && PathPrefix(\`/instances/${options.instanceId}\`)`,
                [`traefik.http.routers.${routerName}.entrypoints`]: 'websecure',
                [`traefik.http.routers.${routerName}.tls.certresolver`]: 'myresolver',
                [`traefik.http.services.${routerName}.loadbalancer.server.port`]: '8080',
                // Middleware to strip the prefix, so /instances/123/qr becomes /qr for the container
                [`traefik.http.middlewares.${routerName}-stripprefix.stripprefix.prefixes`]: `/instances/${options.instanceId}`,
                [`traefik.http.routers.${routerName}.middlewares`]: `${routerName}-stripprefix`,
            },
            HostConfig: {
                RestartPolicy: { Name: 'unless-stopped' },
                Memory: parseMemory(options.memoryLimit), 
                NanoCpus: parseFloat(options.cpuLimit || '0') * 1e9,
                NetworkMode: 'worker-net', // Connect to the shared traefik network
            },
        });

        // 3. Start the container
        await container.start();
        console.log(`Container started with ID: ${container.id}`);

        return container.inspect();
    }


    export async function stopAndRemoveContainer(instanceId: number, node:
    WorkerNode) {
        const docker = getDockerClientForNode(node);
        try {
            const container = await findContainer(instanceId, node);
            if (!container) {
                console.log(`Container for instance ${instanceId} on node ${node.dockerHost} not found, nothing to do.`);
                return;
            }

            console.log(`Stopping and removing container ${container.Id} for instance ${instanceId}`);
            const containerInstance = docker.getContainer(container.Id);
            
            // Stop with a 10-second timeout to allow graceful shutdown
            await containerInstance.stop({ t: 10 }).catch(err => {
                // Ignore "container already stopped" or "no such container" errors
                if (err.statusCode !== 304 && err.statusCode !== 404) throw err;
            });

            await containerInstance.remove().catch(err => {
                 // Ignore "no such container" errors
                if (err.statusCode !== 404) throw err;
            });
            console.log(`Container for instance ${instanceId} removed successfully.`);
        } catch (error: any) {
            if (error.statusCode === 404) {
                 console.log(`Container for instance ${instanceId} on node ${node.dockerHost} not found, nothing to do.`);
                 return;
            }
            console.error(`Error stopping/removing container for instance ${instanceId} on node ${node.dockerHost}:`, error);
            throw error;
        }
    }


    export async function findContainer(instanceId: number, node: WorkerNode):
    Promise<Dockerode.ContainerInfo | null> {
        const docker = getDockerClientForNode(node);
        try {
            const containers = await docker.listContainers({
                all: true,
                filters: {
                    label: [`whatsapp-gateway-saas.instance-id=${instanceId}`]
                }
            });

            if (containers.length === 0) {
                return null;
            }
            if (containers.length > 1) {
                console.warn(`Found multiple containers for instance ${instanceId} on node ${node.dockerHost}. Using the first one.`);
            }
            return containers[0];
        } catch (error) {
            console.error(`Error finding container for instance ${instanceId} on node ${node.dockerHost}:`, error);
            return null;
        }
    }


    async function pullImage(imageName: string, node: WorkerNode): Promise<void>
    {
        const docker = getDockerClientForNode(node);
        console.log(`Ensuring image ${imageName} is available on node ${node.dockerHost}...`);
        try {
            const images = await docker.listImages({ filters: { reference: [imageName] } });
            if (images.length > 0) {
                console.log(`Image ${imageName} already exists on node.`);
                return;
            }

            console.log(`Pulling image ${imageName} on node ${node.dockerHost}...`);
            const pullStream = await docker.pull(imageName);
            
            await new Promise<void>((resolve, reject) => {
                docker.modem.followProgress(pullStream, (err, _res) => err ? reject(err) : resolve());
            });

            console.log(`Image ${imageName} pulled successfully on node.`);
        } catch (error) {
            console.error(`Failed to pull image ${imageName} on node ${node.dockerHost}:`, error);
            throw error;
        }
    }


    function parseMemory(memoryStr: string): number {
        if (!memoryStr) return 0; // default
        const unit = memoryStr.slice(-1).toLowerCase();
        const value = parseFloat(memoryStr.slice(0, -1));

        if (isNaN(value)) return 0;

        switch (unit) {
            case 'g': return value * 1024 * 1024 * 1024;
            case 'm': return value * 1024 * 1024;
            case 'k': return value * 1024;
            default: return parseFloat(memoryStr); // Assume bytes if no unit
        }
    }
  gateway/tsconfig.json: |-
    {
      "compilerOptions": {
        "lib": ["ESNext"],
        "module": "ESNext",
        "target": "ESNext",
        "moduleResolution": "bundler",
        "moduleDetection": "force",
        "allowImportingTsExtensions": true,
        "noEmit": true,
        "composite": true,
        "strict": true,
        "downlevelIteration": true,
        "skipLibCheck": true,
        "jsx": "react-jsx",
        "allowSyntheticDefaultImports": true,
        "forceConsistentCasingInFileNames": true,
        "allowJs": true,
        "types": [
          "bun-types"
        ]
      },
      "include": [
        "src",
        "../drizzle/schema.ts"
      ]
    }
approved: true
linesAdded: 81
linesRemoved: 4
linesDifference: 85
gitCommittedAt: null
status: committed
id: 15
