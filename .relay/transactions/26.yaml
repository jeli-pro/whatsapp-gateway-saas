uuid: 18408f61-b541-4c12-870c-26d18a14d593
projectId: whatsapp-gateway-saas
createdAt: '2025-11-18T02:54:34.833Z'
gitCommitMsg: >-
  feat(api): add admin crud api for worker node management

  Implements a new secure /admin/nodes endpoint for creating, reading, updating,
  and deleting worker nodes. This is a critical feature for dynamically managing
  the infrastructure fleet.

  - Adds a new ADMIN_API_SECRET for authenticating privileged operations. -
  Creates a new /admin API group in the gateway with authentication middleware.
  - Implements the full set of CRUD endpoints for the `nodes` resource. -
  Includes a safety check to prevent deletion of a node if it still has active
  instances, returning a 409 Conflict status. - Adds a comprehensive E2E test
  suite to validate authentication, all CRUD operations, and the
  instance-deletion constraint.
promptSummary: Implement the second plan to create a CRUD API for worker node management.
reasoning:
  - >-
    I will now implement the plan to add a secure CRUD API for managing worker
    nodes, complete with a full suite of E2E tests.
  - >-
    First, I'll update the environment configuration to include the new
    `ADMIN_API_SECRET`.
  - >-
    Next, I'll update the test setup utilities and helpers to be aware of the
    new admin secret.
  - >-
    Now I'll implement the admin API endpoints for node management in the main
    application file.
  - >-
    Finally, I'll create the new E2E test suite to validate the node management
    API.
operations:
  - type: write
    path: .env.example
    content: >
      <<<<<<< SEARCH

      INTERNAL_API_SECRET="a-different-and-very-strong-secret-for-internal-comms"

      GATEWAY_URL="http://host.docker.internal:3000" # URL for provider
      containers to reach the gateway

      =======

      INTERNAL_API_SECRET="a-different-and-very-strong-secret-for-internal-comms"

      ADMIN_API_SECRET="a-secret-for-privileged-admin-operations"

      GATEWAY_URL="http://host.docker.internal:3000" # URL for provider
      containers to reach the gateway

      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: write
    path: .env.test
    content: |
      <<<<<<< SEARCH
      API_SECRET="test-api-key-secret-for-ci"
      INTERNAL_API_SECRET="test-internal-secret-for-ci"
      GATEWAY_URL="http://host.docker.internal:3000"
      =======
      API_SECRET="test-api-key-secret-for-ci"
      INTERNAL_API_SECRET="test-internal-secret-for-ci"
      ADMIN_API_SECRET="test-admin-secret-for-ci"
      GATEWAY_URL="http://host.docker.internal:3000"
      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: write
    path: gateway/tests/utils/test-setup.ts
    content: |
      <<<<<<< SEARCH
      export interface TestEnvironment {
        DATABASE_URL: string;
        INTERNAL_API_SECRET: string;
        API_SECRET: string;
        GATEWAY_URL: string;
        NODE_ENV: string;
      }
      =======
      export interface TestEnvironment {
        DATABASE_URL: string;
        INTERNAL_API_SECRET: string;
        API_SECRET: string;
        ADMIN_API_SECRET: string;
        GATEWAY_URL: string;
        NODE_ENV: string;
      }
      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: write
    path: gateway/tests/utils/test-setup.ts
    content: |
      <<<<<<< SEARCH
      async function setupEnvironment(): Promise<TestEnvironment> {
        const testEnv: TestEnvironment = {
          DATABASE_URL: 'postgresql://test_user:test_password@localhost:5433/test_db',
          INTERNAL_API_SECRET: 'test-internal-secret-for-ci',
          API_SECRET: 'test-api-key-secret-for-ci',
          GATEWAY_URL: 'http://localhost:3000',
          NODE_ENV: 'test'
        };
      =======
      async function setupEnvironment(): Promise<TestEnvironment> {
        const testEnv: TestEnvironment = {
          DATABASE_URL: 'postgresql://test_user:test_password@localhost:5433/test_db',
          INTERNAL_API_SECRET: 'test-internal-secret-for-ci',
          API_SECRET: 'test-api-key-secret-for-ci',
          ADMIN_API_SECRET: 'test-admin-secret-for-ci',
          GATEWAY_URL: 'http://localhost:3000',
          NODE_ENV: 'test'
        };
      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: write
    path: gateway/tests/helpers/setup.ts
    content: >
      <<<<<<< SEARCH

      // --- Test Constants (initialized in setup) ---

      export let TEST_USER_API_KEY: string;

      export let TEST_INTERNAL_API_SECRET: string;

      export const TEST_NODE_DOCKER_HOST = process.env.TEST_DOCKER_HOST ||
      'unix:///var/run/docker.sock';

      =======

      // --- Test Constants (initialized in setup) ---

      export let TEST_USER_API_KEY: string;

      export let TEST_INTERNAL_API_SECRET: string;

      export let TEST_ADMIN_API_SECRET: string;

      export const TEST_NODE_DOCKER_HOST = process.env.TEST_DOCKER_HOST ||
      'unix:///var/run/docker.sock';

      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: write
    path: gateway/tests/helpers/setup.ts
    content: |
      <<<<<<< SEARCH
        const env = getEnvironment(); // This will now succeed.
        TEST_USER_API_KEY = env.API_SECRET;
        TEST_INTERNAL_API_SECRET = env.INTERNAL_API_SECRET;
      =======
        const env = getEnvironment(); // This will now succeed.
        TEST_USER_API_KEY = env.API_SECRET;
        TEST_INTERNAL_API_SECRET = env.INTERNAL_API_SECRET;
        TEST_ADMIN_API_SECRET = env.ADMIN_API_SECRET;
      >>>>>>> REPLACE
    patchStrategy: search-replace
  - type: write
    path: gateway/src/app.ts
    content: >
      --- gateway/src/app.ts

      +++ gateway/src/app.ts

      @@ -351,5 +351,77 @@
                         set: { value }
                     });
       
                 set.status = 204;
             }, { body: t.ArrayBuffer() })
      -    );

      +    )

      +    // New admin API group for node management

      +    .group('/admin', (app) => app

      +        .onBeforeHandle(({ headers, set }) => {

      +            const adminSecret = process.env.ADMIN_API_SECRET;

      +            if (!adminSecret) {

      +                console.error('ADMIN_API_SECRET is not set. Admin API is
      disabled.');

      +                set.status = 503;

      +                return { error: 'Service Unavailable' };

      +            }

      +            if (headers['x-admin-api-secret'] !== adminSecret) {

      +                set.status = 401;

      +                return { error: 'Unauthorized' };

      +            }

      +        })

      +        .post('/nodes', async ({ body, set }) => {

      +            const [newNode] = await
      db.insert(schema.nodes).values(body).returning();

      +            if (!newNode) {

      +                set.status = 500;

      +                return { error: 'Failed to create node' };

      +            }

      +            return newNode;

      +        }, {

      +            body: t.Object({

      +                name: t.String(),

      +                dockerHost: t.String(),

      +                publicHost: t.String(),

      +            })

      +        })

      +        .get('/nodes', async () => {

      +            return await db.select().from(schema.nodes);

      +        })

      +        .get('/nodes/:id', async ({ params, set }) => {

      +            const [node] = await
      db.select().from(schema.nodes).where(eq(schema.nodes.id, params.id));

      +            if (!node) {

      +                set.status = 404;

      +                return { error: 'Node not found' };

      +            }

      +            return node;

      +        }, {

      +            params: t.Object({ id: t.Numeric() })

      +        })

      +        .put('/nodes/:id', async ({ params, body, set }) => {

      +            const [updatedNode] = await db.update(schema.nodes)

      +                .set(body)

      +                .where(eq(schema.nodes.id, params.id))

      +                .returning();

      +            if (!updatedNode) {

      +                set.status = 404;

      +                return { error: 'Node not found' };

      +            }

      +            return updatedNode;

      +        }, {

      +            params: t.Object({ id: t.Numeric() }),

      +            body: t.Object({

      +                name: t.Optional(t.String()),

      +                dockerHost: t.Optional(t.String()),

      +                publicHost: t.Optional(t.String()),

      +            })

      +        })

      +        .delete('/nodes/:id', async ({ params, set }) => {

      +            try {

      +                const result = await
      db.delete(schema.nodes).where(eq(schema.nodes.id, params.id)).returning();

      +                if (result.length === 0) {

      +                    set.status = 404;

      +                    return { error: 'Node not found' };

      +                }

      +                set.status = 204;

      +            } catch (error: any) {

      +                // Check for foreign key violation (Postgres error code
      23503)

      +                if (error.code === '23503') {

      +                    set.status = 409;

      +                    return { error: 'Cannot delete node because it has
      instances assigned to it.' };

      +                }

      +                console.error('Failed to delete node:', error);

      +                set.status = 500;

      +                return { error: 'Internal server error' };

      +            }

      +        }, {

      +            params: t.Object({ id: t.Numeric() })

      +        })

      +    );
       }
    patchStrategy: standard-diff
  - type: write
    path: gateway/tests/e2e/nodes.test.ts
    content: >-
      import { describe, test, expect, beforeAll, afterAll, afterEach } from
      'bun:test';

      import { db, setup, teardown, cleanupDb, createTestInstance,
      TEST_ADMIN_API_SECRET, type User, type Node } from '../helpers/setup';

      import * as schema from '../../../drizzle/schema';

      import { eq, ne } from 'drizzle-orm';


      describe('E2E - Admin Node Management API', () => {
          let serverUrl: string;
          let appInstance: any;
          let testUser: User;
          let initialNode: Node;

          beforeAll(async () => {
              const setupResult = await setup(); // Sets up 1 initial node
              serverUrl = setupResult.serverUrl;
              appInstance = setupResult.app;
              testUser = setupResult.user;
              initialNode = setupResult.nodes[0];
          });

          afterAll(async () => {
              if (appInstance) {
                  await teardown(appInstance);
              }
          });

          afterEach(async () => {
              // Clean up any instances created during tests
              await cleanupDb();
              
              // Clean up any nodes created during tests, leaving the initial one
              await db.delete(schema.nodes).where(ne(schema.nodes.id, initialNode.id));
          });

          test('should reject access without the admin secret', async () => {
              const res = await fetch(`${serverUrl}/admin/nodes`);
              expect(res.status).toBe(401);

              const postRes = await fetch(`${serverUrl}/admin/nodes`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ name: 'node-x', dockerHost: 'host', publicHost: 'public' })
              });
              expect(postRes.status).toBe(401);
          });

          test('should create, list, get, update, and delete a node', async () => {
              const newNodeData = {
                  name: 'test-node-2',
                  dockerHost: 'unix:///var/run/docker.sock',
                  publicHost: 'test-node-2.local'
              };

              // 1. Create Node
              const createResponse = await fetch(`${serverUrl}/admin/nodes`, {
                  method: 'POST',
                  headers: {
                      'Content-Type': 'application/json',
                      'X-Admin-API-Secret': TEST_ADMIN_API_SECRET
                  },
                  body: JSON.stringify(newNodeData)
              });
              expect(createResponse.status).toBe(200);
              const createdNode = await createResponse.json() as Node;
              expect(createdNode.id).toBeTypeOf('number');
              expect(createdNode.name).toBe(newNodeData.name);

              const nodeId = createdNode.id;

              // 2. List Nodes
              const listResponse = await fetch(`${serverUrl}/admin/nodes`, {
                  headers: { 'X-Admin-API-Secret': TEST_ADMIN_API_SECRET }
              });
              expect(listResponse.status).toBe(200);
              const nodes = await listResponse.json() as Node[];
              expect(nodes.length).toBe(2); // Initial node + new node
              expect(nodes.find(n => n.id === nodeId)).toBeDefined();

              // 3. Get Node by ID
              const getResponse = await fetch(`${serverUrl}/admin/nodes/${nodeId}`, {
                  headers: { 'X-Admin-API-Secret': TEST_ADMIN_API_SECRET }
              });
              expect(getResponse.status).toBe(200);
              const fetchedNode = await getResponse.json() as Node;
              expect(fetchedNode.id).toBe(nodeId);
              expect(fetchedNode.name).toBe(newNodeData.name);

              // 4. Update Node
              const updatedName = 'test-node-2-updated';
              const updateResponse = await fetch(`${serverUrl}/admin/nodes/${nodeId}`, {
                  method: 'PUT',
                  headers: {
                      'Content-Type': 'application/json',
                      'X-Admin-API-Secret': TEST_ADMIN_API_SECRET
                  },
                  body: JSON.stringify({ name: updatedName })
              });
              expect(updateResponse.status).toBe(200);
              const updatedNode = await updateResponse.json() as Node;
              expect(updatedNode.name).toBe(updatedName);

              // 5. Delete Node
              const deleteResponse = await fetch(`${serverUrl}/admin/nodes/${nodeId}`, {
                  method: 'DELETE',
                  headers: { 'X-Admin-API-Secret': TEST_ADMIN_API_SECRET }
              });
              expect(deleteResponse.status).toBe(204);

              // 6. Verify Deletion
              const getAfterDeleteResponse = await fetch(`${serverUrl}/admin/nodes/${nodeId}`, {
                  headers: { 'X-Admin-API-Secret': TEST_ADMIN_API_SECRET }
              });
              expect(getAfterDeleteResponse.status).toBe(404);
          });

          test('should return 409 Conflict when deleting a node with active instances', async () => {
              // The initialNode from setup is our target
              const nodeToDelete = initialNode;

              // 1. Create an instance assigned to this node
              const testInstance = await createTestInstance(db, testUser, nodeToDelete);
              expect(testInstance.nodeId).toBe(nodeToDelete.id);

              // 2. Attempt to delete the node
              const deleteResponse = await fetch(`${serverUrl}/admin/nodes/${nodeToDelete.id}`, {
                  method: 'DELETE',
                  headers: { 'X-Admin-API-Secret': TEST_ADMIN_API_SECRET }
              });
              
              // 3. Assert a 409 Conflict response
              expect(deleteResponse.status).toBe(409);
              const errorBody = await deleteResponse.json();
              expect(errorBody.error).toBe('Cannot delete node because it has instances assigned to it.');

              // 4. Verify the node still exists in the database
              const getNodeResponse = await fetch(`${serverUrl}/admin/nodes/${nodeToDelete.id}`, {
                  headers: { 'X-Admin-API-Secret': TEST_ADMIN_API_SECRET }
              });
              expect(getNodeResponse.status).toBe(200);
          });
      });
    patchStrategy: replace
snapshot:
  gateway/tests/e2e/nodes.test.ts: null
  .env.example: >-
    DATABASE_URL="postgresql://user:password@localhost:5432/whatsapp_gateway"

    API_SECRET="your-super-secret-api-key"

    INTERNAL_API_SECRET="a-different-and-very-strong-secret-for-internal-comms"

    GATEWAY_URL="http://host.docker.internal:3000" # URL for provider containers
    to reach the gateway
  .env.test: |-
    DATABASE_URL="postgresql://test_user:test_password@localhost:5433/test_db"
    API_SECRET="test-api-key-secret-for-ci"
    INTERNAL_API_SECRET="test-internal-secret-for-ci"
    GATEWAY_URL="http://host.docker.internal:3000"
  gateway/tests/utils/test-setup.ts: |-
    import { spawn } from 'child_process';
    import { existsSync } from 'fs';
    import { join } from 'path';
    import { drizzle } from 'drizzle-orm/postgres-js';
    import postgres, { type Sql } from 'postgres';
    import * as schema from '../../../drizzle/schema';
    import { promises as fs } from 'fs';

    export interface TestEnvironment {
      DATABASE_URL: string;
      INTERNAL_API_SECRET: string;
      API_SECRET: string;
      GATEWAY_URL: string;
      NODE_ENV: string;
    }

    let dbConnection: Sql | null = null;
    let db: any = null;
    let envFileCreated = false;
    let migrationsRun = false;
    let env: TestEnvironment | null = null;

    export function getEnvironment(): TestEnvironment {
      if (!env) {
        throw new Error('Test environment is not initialized. Call ensureTestEnvironment() first.');
      }
      return env;
    }

    /**
     * Ensures the test environment is properly set up
     */
    export async function ensureTestEnvironment(): Promise<TestEnvironment> {
      if (env) {
        return env;
      }
      console.log('üîß Setting up test environment...');

      // Set up environment variables
      const testEnv = await setupEnvironment();

      // Start test database if needed
      await ensureTestDatabase();

      // Set up database schema
      await ensureDatabaseSchema();

      console.log('‚úÖ Test environment ready');
      return testEnv;
    }

    /**
     * Sets up the test environment variables
     */
    async function setupEnvironment(): Promise<TestEnvironment> {
      const testEnv: TestEnvironment = {
        DATABASE_URL: 'postgresql://test_user:test_password@localhost:5433/test_db',
        INTERNAL_API_SECRET: 'test-internal-secret-for-ci',
        API_SECRET: 'test-api-key-secret-for-ci',
        GATEWAY_URL: 'http://localhost:3000',
        NODE_ENV: 'test'
      };

      // Set environment variables
      Object.entries(testEnv).forEach(([key, value]) => {
        process.env[key] = value;
      });

      // Store for later retrieval
      env = testEnv;

      // Create .env.test file if it doesn't exist
      const gatewayDir = join(process.cwd());
      const envTestPath = join(gatewayDir, '.env.test');

      if (!existsSync(envTestPath)) {
        const envContent = Object.entries(testEnv)
          .map(([key, value]) => `${key}=${value}`)
          .join('\n');

        await fs.writeFile(envTestPath, envContent);
        envFileCreated = true;
        console.log('üìù Created .env.test file');
      }

      return testEnv;
    }

    /**
     * Ensures test database is running and accessible
     */
    async function ensureTestDatabase(): Promise<void> {
      console.log('üóÑÔ∏è  Checking test database...');

      try {
        // Try to connect to the database
        const client = postgres(process.env.DATABASE_URL!, { timeout: 5000 });
        await client`SELECT 1`;
        await client.end();
        console.log('‚úÖ Test database is accessible');
        return;
      } catch (error) {
        console.log('‚ö†Ô∏è  Test database not accessible, starting it...');
        await startTestDatabase();
      }
    }

    /**
     * Starts the test database using Docker
     */
    async function startTestDatabase(): Promise<void> {
      return new Promise((resolve, reject) => {
        console.log('üê≥ Starting test database container...');

        // Stop existing container if it exists
        const stopCmd = spawn('docker', [
          'stop', 'whatsapp-gateway-saas-test-db'
        ], { stdio: 'pipe' });

        stopCmd.on('close', () => {
          const rmCmd = spawn('docker', [
            'rm', 'whatsapp-gateway-saas-test-db'
          ], { stdio: 'pipe' });

          rmCmd.on('close', () => {
            const runCmd = spawn('docker', [
              'run', '-d',
              '--name', 'whatsapp-gateway-saas-test-db',
              '-e', 'POSTGRES_USER=test_user',
              '-e', 'POSTGRES_PASSWORD=test_password',
              '-e', 'POSTGRES_DB=test_db',
              '-p', '5433:5432',
              '--restart', 'unless-stopped',
              'postgres:16-alpine'
            ], { stdio: 'pipe' });

            runCmd.on('close', (code) => {
              if (code === 0) {
                console.log('‚úÖ Test database container started');
                waitForDatabase().then(resolve).catch(reject);
              } else {
                reject(new Error('Failed to start test database container'));
              }
            });

            runCmd.on('error', reject);
          });

          rmCmd.on('error', () => {
            // Container might not exist, which is fine
            console.log('‚ÑπÔ∏è  No existing container to remove');
            const runCmd = spawn('docker', [
              'run', '-d',
              '--name', 'whatsapp-gateway-saas-test-db',
              '-e', 'POSTGRES_USER=test_user',
              '-e', 'POSTGRES_PASSWORD=test_password',
              '-e', 'POSTGRES_DB=test_db',
              '-p', '5433:5432',
              '--restart', 'unless-stopped',
              'postgres:16-alpine'
            ], { stdio: 'pipe' });

            runCmd.on('close', (code) => {
              if (code === 0) {
                console.log('‚úÖ Test database container started');
                waitForDatabase().then(resolve).catch(reject);
              } else {
                reject(new Error('Failed to start test database container'));
              }
            });

            runCmd.on('error', reject);
          });
        });

        stopCmd.on('error', () => {
          // Container might not exist, which is fine
          console.log('‚ÑπÔ∏è  No existing container to stop');
        });
      });
    }

    /**
     * Waits for the database to be ready
     */
    async function waitForDatabase(): Promise<void> {
      console.log('‚è≥ Waiting for database to be ready...');

      for (let i = 0; i < 30; i++) {
        try {
          const client = postgres(process.env.DATABASE_URL!, { timeout: 5000 });
          await client`SELECT 1`;
          await client.end();
          console.log('‚úÖ Database is ready');
          return;
        } catch (error) {
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      }

      throw new Error('Database failed to become ready within 30 seconds');
    }

    /**
     * Ensures the database schema is set up
     */
    async function ensureDatabaseSchema(): Promise<void> {
      if (migrationsRun) {
        return;
      }

      console.log('üóÉÔ∏è  Setting up database schema...');

      try {
        // Try to connect and check if tables exist
        await connectToDatabase();

        // Check if tables exist by trying to query one of them
        try {
          await db.query.users.findFirst();
          console.log('‚úÖ Database schema already exists');
          migrationsRun = true;
          return;
        } catch (error) {
          // Tables don't exist, need to run migrations
          console.log('üîÑ Database schema needs to be created');
        }

        // Run migrations
        await runMigrations();
        migrationsRun = true;
        console.log('‚úÖ Database schema created successfully');

      } catch (error) {
        console.error('‚ùå Failed to set up database schema:', error);
        throw error;
      }
    }

    /**
     * Connects to the database
     */
    async function connectToDatabase(): Promise<void> {
      if (dbConnection) {
        return;
      }

      dbConnection = postgres(process.env.DATABASE_URL!);
      db = drizzle(dbConnection, { schema });
    }

    /**
     * Runs database migrations
     */
    async function runMigrations(): Promise<void> {
      console.log('üì¶ Running database migrations...');

      return new Promise((resolve, reject) => {
        const { spawn } = require('child_process');

        // First, generate migrations if they don't exist
        const generateCmd = spawn('npx', ['drizzle-kit', 'generate'], {
          cwd: join(process.cwd(), '..'),
          stdio: 'pipe'
        });

        generateCmd.on('close', (code: number | null) => {
          if (code === 0) {
            console.log('‚úÖ Migrations generated');

            // Then run the migrations
            const migrateCmd = spawn('npx', ['drizzle-kit', 'migrate'], {
              cwd: join(process.cwd(), '..'),
              stdio: 'pipe'
            });

            migrateCmd.on('close', (code: number | null) => {
              if (code === 0) {
                console.log('‚úÖ Migrations applied successfully');
                resolve();
              } else {
                reject(new Error('Migration failed'));
              }
            });

            migrateCmd.on('error', reject);
          } else {
            reject(new Error('Migration generation failed'));
          }
        });

        generateCmd.on('error', reject);
      });
    }

    /**
     * Gets the database connection for tests
     */
    export async function getDb() {
      if (!db) {
        await connectToDatabase();
      }
      return db;
    }

    /**
     * Cleans up the test environment
     */
    export async function cleanup(): Promise<void> {
      console.log('üßπ Cleaning up test environment...');

      if (dbConnection) {
        try {
          await dbConnection.end({ timeout: 5 });
          dbConnection = null;
          db = null;
        } catch (error) {
          console.warn('‚ö†Ô∏è  Failed to close database connection:', error);
        }
      }

      if (envFileCreated) {
        try {
          const gatewayDir = join(process.cwd());
          const envTestPath = join(gatewayDir, '.env.test');
          await fs.unlink(envTestPath);
          console.log('üóëÔ∏è  Removed .env.test file');
          envFileCreated = false; // Reset for next test run
        } catch (error) {
          console.warn('‚ö†Ô∏è  Failed to remove .env.test file:', error);
        }
      }

      // Only clean up database container if explicitly requested or no other tests are running
      // This prevents cleanup conflicts when multiple test files are running
    }

    /**
     * Force cleanup of database container (for explicit cleanup only)
     */
    export async function forceCleanup(): Promise<void> {
      console.log('üßπ Force cleaning up test environment...');

      if (dbConnection) {
        try {
          await dbConnection.end({ timeout: 5 });
          dbConnection = null;
          db = null;
        } catch (error) {
          console.warn('‚ö†Ô∏è  Failed to close database connection:', error);
        }
      }

      if (envFileCreated) {
        try {
          const gatewayDir = join(process.cwd());
          const envTestPath = join(gatewayDir, '.env.test');
          await fs.unlink(envTestPath);
          console.log('üóëÔ∏è  Removed .env.test file');
        } catch (error) {
          console.warn('‚ö†Ô∏è  Failed to remove .env.test file:', error);
        }
      }

      // Stop test database container
      try {
        const { spawn } = require('child_process');
        const stopCmd = spawn('docker', ['stop', 'whatsapp-gateway-saas-test-db'], { stdio: 'pipe' });

        stopCmd.on('close', () => {
          const rmCmd = spawn('docker', ['rm', 'whatsapp-gateway-saas-test-db'], { stdio: 'pipe' });
          rmCmd.on('close', () => {
            console.log('‚úÖ Test database container stopped and removed');
          });
        });
      } catch (error) {
        console.warn('‚ö†Ô∏è  Failed to clean up test database container:', error);
      }
    }
  gateway/tests/helpers/setup.ts: >-
    import { drizzle, type PostgresJsDatabase } from 'drizzle-orm/postgres-js';

    import postgres, { type Sql } from 'postgres';

    import { getDockerClientForNode, type ContainerInfo } from
    '../../src/docker.client';

    import * as schema from '../../../drizzle/schema';

    import { createApp } from '../../src/app';

    import { ensureTestEnvironment, getEnvironment, cleanup as testCleanup }
    from '../utils/test-setup';


    // --- Types ---

    export type User = typeof schema.users.$inferSelect;

    export type Node = typeof schema.nodes.$inferSelect;

    export type Instance = typeof schema.instances.$inferSelect;


    // --- DB Connection ---

    // These are initialized in setup() to prevent connection attempts before
    the test DB is ready.

    let client: Sql;

    export let db: PostgresJsDatabase<typeof schema>;


    // --- Test Constants (initialized in setup) ---

    export let TEST_USER_API_KEY: string;

    export let TEST_INTERNAL_API_SECRET: string;

    export const TEST_NODE_DOCKER_HOST = process.env.TEST_DOCKER_HOST ||
    'unix:///var/run/docker.sock';

    export const TEST_NODE_PUBLIC_HOST_PREFIX = 'test-node.local';


    const docker = getDockerClientForNode({ dockerHost: TEST_NODE_DOCKER_HOST
    });


    interface SetupOptions {
      nodeCount?: number;
    }



    /**
     * Sets up the test environment:
     * 1. Establishes DB connection.
     * 2. Starts the API server on a random available port.
     * 3. Cleans and seeds the database with a test user and a test node.
     * @returns An object with the server URL and the created user/node entities.
     */
    export const setup = async (options: SetupOptions = {}) => {
      const { nodeCount = 1 } = options;
      // Ensure the environment is ready. This is idempotent and safe to call.
      await ensureTestEnvironment();

      const env = getEnvironment(); // This will now succeed.
      TEST_USER_API_KEY = env.API_SECRET;
      TEST_INTERNAL_API_SECRET = env.INTERNAL_API_SECRET;

      // 1. Establish DB connection
      // Use the connection string from the now-initialized environment
      const connectionString = env.DATABASE_URL;
      if (!connectionString) {
        throw new Error("DATABASE_URL is not set. Please create a .env.test file.");
      }
      client = postgres(connectionString);
      db = drizzle(client, { schema });

      // 2. Create app with database and start server on a random available port
      const app = createApp(db);
      await app.listen(0);

      // 3. Clean database before seeding to ensure a fresh state.
      await db.delete(schema.instanceState);
      await db.delete(schema.instances);
      await db.delete(schema.users);
      await db.delete(schema.nodes);

      const [testUser] = await db.insert(schema.users).values({
        email: `test-${Date.now()}@example.com`,
        apiKey: TEST_USER_API_KEY,
      }).returning();

      const testNodes: Node[] = [];
      for (let i = 0; i < nodeCount; i++) {
        const [testNode] = await db.insert(schema.nodes).values({
          name: `test-node-${i + 1}`,
          dockerHost: TEST_NODE_DOCKER_HOST,
          publicHost: `${TEST_NODE_PUBLIC_HOST_PREFIX}-${i + 1}`,
        }).returning();
        testNodes.push(testNode);
      }

      return {
        serverUrl: `http://localhost:${app.server?.port}`,
        user: testUser,
        nodes: testNodes,
        app, // Return app instance for teardown
      };
    };


    /**
     * Tears down the test environment:
     * 1. Stops the API server.
     * 2. Closes the database connection.
     * 3. Cleans up test database and environment.
     */
    export const teardown = async (app: any) => {
      await app.stop();
      if (client) {
        await client.end({ timeout: 5 });
      }
      // Clean up the test environment (but not the database container)
      await testCleanup();
    };


    /**
     * Removes all instance-related records from the database.
     */
    export const cleanupDb = async () => {
        // db is guaranteed to be initialized by setup() in beforeAll
        await db.delete(schema.instanceState);
        await db.delete(schema.instances);
    };


    /**
     * Helper to create a test instance in the database.
     */
    export async function createTestInstance(
        db: PostgresJsDatabase<typeof schema>,
        user: User,
        node: Node,
        overrides: Partial<Omit<Instance, 'id' | 'userId' | 'nodeId'>> = {}
    ): Promise<Instance> {
        const [instance] = await db.insert(schema.instances).values({
            nodeId: node.id,
            userId: user.id,
            phoneNumber: '9876543210',
            provider: 'whatsmeow',
            status: 'running', // Default to running for most API tests
            ...overrides,
        }).returning();
        return instance;
    }


    /**
     * Finds and removes all Docker containers created by the tests.
     */
    export const cleanupContainers = async () => {
        const containers = await docker.listContainers({
            all: true,
            filters: { label: [`whatsapp-gateway-saas.instance-id`] }
        });

        for (const containerInfo of containers) {
            console.log(`Cleaning up test container: ${containerInfo.Id}`);
            try {
                await docker.stopContainer(containerInfo.Id, { t: 5 });
            } catch (e: any) {
                // Ignore if already stopped (304) or not found (404)
                if (e.statusCode !== 304 && e.statusCode !== 404) console.error(e);
            }
            try {
                await docker.removeContainer(containerInfo.Id);
            } catch (e: any) {
                 // Ignore if not found (404)
                if (e.statusCode !== 404) console.error(e);
            }
        }
    };


    /**
     * Test helper to find a container by its instance ID label.
     * @param instanceId The ID of the instance.
     * @returns ContainerInfo if found, otherwise undefined.
     */
    export async function findContainerByInstanceId(instanceId: number):
    Promise<ContainerInfo | undefined> {
        const containers = await docker.listContainers({
            all: true,
            filters: { label: [`whatsapp-gateway-saas.instance-id=${instanceId}`] }
        });
        return containers[0];
    }
  gateway/src/app.ts: >-
    import { Elysia, t } from 'elysia';

    import { eq, and, not } from 'drizzle-orm';

    import * as schema from '../../drizzle/schema';

    import { createAndStartContainer, stopAndRemoveContainer, type WorkerNode }
    from './docker.service';


    /**
     * Creates the Elysia app instance with all routes configured.
     * Database connection is injected to avoid circular dependencies in tests.
     */
    export function createApp(db: any) {
      // A simple proxy to fetch data from an instance via its public URL
      async function proxyToInstance(instanceUrl: string, options?: RequestInit) {
          try {
              const response = await fetch(instanceUrl, options);
              return response;
          } catch (e) {
              console.error(`Failed to proxy request to ${instanceUrl}`, e);
              return null;
          }
      }

      return new Elysia()
        .get('/', () => ({ status: 'ok' }))
        .group('/api', (app) => app
          // Resolve user from API Key
          .resolve(async ({ headers }) => {
              const auth = headers['authorization'];
              if (!auth || !auth.startsWith('Bearer ')) {
                  return { user: null };
              }
              const apiKey = auth.substring(7);
              if (!apiKey) {
                  return { user: null };
              }
              const [user] = await db.select().from(schema.users).where(eq(schema.users.apiKey, apiKey));

              return { user: user || null };
          })
          // Simple bearer token auth
          .onBeforeHandle(({ user, set }) => {
              if (!user) {
                  set.status = 401;
                  return { error: 'Unauthorized' };
              }
          })
          .post('/instances', async ({ body, set, user }) => {
              // Select a node for the new instance. Simple round-robin or first-available logic.
              // For now, just pick the first one.
              const [node] = await db.select().from(schema.nodes).limit(1);
              if (!node) {
                  set.status = 503;
                  return { error: 'No available worker nodes to schedule instance.' };
              }

              // user is guaranteed to be non-null by the onBeforeHandle guard.
              const [newInstance] = await db.insert(schema.instances).values({
                  nodeId: node.id,
                  userId: user!.id,
                  name: body.name,
                  phoneNumber: body.phone,
                  provider: body.provider,
                  webhookUrl: body.webhook,
                  cpuLimit: body.resources?.cpu,
                  memoryLimit: body.resources?.memory,
                  status: 'creating',
              }).returning();

              if (!newInstance) {
                  set.status = 500;
                  return { error: 'Failed to create instance in database' };
              }

              try {
                  await createAndStartContainer({
                      instanceId: newInstance.id,
                      node: node,
                      name: newInstance.name,
                      webhookUrl: newInstance.webhookUrl || '',
                      cpuLimit: newInstance.cpuLimit || '0.5',
                      memoryLimit: newInstance.memoryLimit || '512m',
                      provider: newInstance.provider,
                  });
                  const [updatedInstance] = await db.update(schema.instances)
                      .set({ status: 'running' })
                      .where(eq(schema.instances.id, newInstance.id))
                      .returning();
                  return updatedInstance;
              } catch (error) {
                  console.error('Failed to start container:', error);
                  await db.update(schema.instances)
                      .set({ status: 'error' })
                      .where(eq(schema.instances.id, newInstance.id));
                  set.status = 500;
                  return { error: 'Failed to start container for instance' };
              }
          }, {
              body: t.Object({
                  name: t.Optional(t.String()),
                  phone: t.String(),
                  provider: t.Union([
                      t.Literal('whatsmeow'),
                      t.Literal('baileys'),
                      t.Literal('wawebjs'),
                      t.Literal('waba')
                  ]),
                  webhook: t.Optional(t.String()),
                  resources: t.Optional(t.Object({
                      cpu: t.String(),
                      memory: t.String(),
                  }))
              })
          })
          .get('/instances/:id/qr', async ({ params, set, user }) => {
              const instanceId = parseInt(params.id, 10);

              // Ownership check and fetch instance with its node
              const [instanceData] = await db.select().from(schema.instances).where(and(eq(schema.instances.id, instanceId), eq(schema.instances.userId, user!.id))).leftJoin(schema.nodes, eq(schema.instances.nodeId, schema.nodes.id));

              if (!instanceData || !instanceData.instances) {
                  set.status = 404;
                  return { error: 'Instance not found' };
              }
              if (!instanceData.nodes) {
                  set.status = 500;
                  return { error: 'Instance is not associated with a node.' };
              }

              const instanceUrl = `https://${instanceData.nodes.publicHost}/instances/${instanceId}/qr`;
              const qrResponse = await proxyToInstance(instanceUrl);
              if (!qrResponse) {
                  set.status = 503;
                  return { error: "Failed to connect to instance container." };
              }
              if (!qrResponse.ok) {
                  set.status = qrResponse.status;
                  return qrResponse.body;
              }

              // The whatsmeow provider returns a PNG. We need to proxy that correctly.
              set.headers['Content-Type'] = qrResponse.headers.get('Content-Type') || 'image/png';
              return qrResponse.blob();
          })
          .post('/instances/:id/send', async ({ params, body, set, user }) => {
              const instanceId = parseInt(params.id, 10);

              // Ownership check
              const [instanceData] = await db.select().from(schema.instances).where(and(eq(schema.instances.id, instanceId), eq(schema.instances.userId, user!.id))).leftJoin(schema.nodes, eq(schema.instances.nodeId, schema.nodes.id));
              if (!instanceData || !instanceData.instances) {
                  set.status = 404;
                  return { error: 'Instance not found' };
              }
              if (!instanceData.nodes) {
                  set.status = 500;
                  return { error: 'Instance is not associated with a node.' };
              }

              const instanceUrl = `https://${instanceData.nodes.publicHost}/instances/${instanceId}/send`;

              const sendResponse = await proxyToInstance(instanceUrl, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify(body)
              });

              if (!sendResponse) {
                  set.status = 503;
                  return { error: "Failed to connect to instance container." };
              }
              set.status = sendResponse.status;
              if (!sendResponse.ok) {
                  const errorText = await sendResponse.text();
                  try {
                      return JSON.parse(errorText);
                  } catch (e) {
                      return { error: errorText.trim() };
                  }
              }
              return await sendResponse.json();
          }, {
              body: t.Object({
                  to: t.String(),
                  text: t.String(),
              })
          })
          .delete('/instances/:id', async ({ params, set, user }) => {
              const instanceId = parseInt(params.id, 10);

              // Ownership check
              const [instanceData] = await db.select().from(schema.instances).where(and(eq(schema.instances.id, instanceId), eq(schema.instances.userId, user!.id))).leftJoin(schema.nodes, eq(schema.instances.nodeId, schema.nodes.id));
              if (!instanceData || !instanceData.instances) {
                  set.status = 404;
                  return { error: 'Instance not found' };
              }
              if (!instanceData.nodes) {
                  // Instance exists but node doesn't. Clean up DB record.
                  await db.delete(schema.instances).where(eq(schema.instances.id, instanceId));
                  return { message: 'Instance found without a node. Record cleaned up.' };
              }

              try {
                  await stopAndRemoveContainer(instanceId, instanceData.nodes);
                  await db.delete(schema.instances).where(eq(schema.instances.id, instanceId));
                  set.status = 204;
              } catch (error) {
                  console.error('Failed to delete instance:', error);
                  set.status = 500;
                  return { error: 'Failed to delete instance' };
              }
          })
          .post('/instances/:id/migrate', async ({ params, set, user, body }) => {
              // The `target_node` from the README is ignored in this single-node implementation.
              const instanceId = parseInt(params.id, 10);

              // 1. Ownership check
              const [instanceData] = await db.select().from(schema.instances).where(and(eq(schema.instances.id, instanceId), eq(schema.instances.userId, user!.id))).leftJoin(schema.nodes, eq(schema.instances.nodeId, schema.nodes.id));
              if (!instanceData || !instanceData.instances || !instanceData.nodes) {
                  set.status = 404;
                  return { error: 'Instance not found or you do not have permission to access it' };
              }

              const instance = instanceData.instances;
              const currentNode = instanceData.nodes;

              // Find a new node to migrate to
              const [newNode] = await db.select().from(schema.nodes).where(not(eq(schema.nodes.id, currentNode.id))).limit(1);
              if (!newNode) {
                  set.status = 503;
                  return { error: 'No available node to migrate to.' };
              }

              console.log(`Starting migration for instance ${instanceId} from node ${currentNode.name} to ${newNode.name}`);

              try {
                  // 2. Set status to 'migrating'
                  await db.update(schema.instances).set({ status: 'migrating' }).where(eq(schema.instances.id, instanceId));

                  // 3. Stop and remove the old container. This triggers the snapshot upload on the provider.
                  await stopAndRemoveContainer(instanceId, currentNode);
                  console.log(`Old container for instance ${instanceId} removed from node ${currentNode.name}.`);

                  // 4. Create and start a new container. The provider will fetch the snapshot on startup.
                  await createAndStartContainer({
                      instanceId: instance.id,
                      node: newNode,
                      name: instance.name,
                      webhookUrl: instance.webhookUrl || '',
                      cpuLimit: instance.cpuLimit || '0.5',
                      memoryLimit: instance.memoryLimit || '512m',
                      provider: instance.provider,
                  });
                  console.log(`New container for instance ${instanceId} started on node ${newNode.name}.`);

                  // 5. Set status back to 'running'
                  const [updatedInstance] = await db.update(schema.instances).set({
                      status: 'running',
                      nodeId: newNode.id,
                  })
                      .where(eq(schema.instances.id, instanceId))
                      .returning();

                  console.log(`Migration for instance ${instanceId} completed successfully.`);
                  return { status: 'ok', instance: updatedInstance };
              } catch (error) {
                  console.error(`Migration failed for instance ${instanceId}:`, error);
                  await db.update(schema.instances).set({ status: 'error' }).where(eq(schema.instances.id, instanceId));
                  set.status = 500;
                  return { error: 'Migration failed' };
              }
          }, {
              body: t.Object({
                  target_node: t.Optional(t.String()),
              })
          })
        )
        // New internal API group for state management
        .group('/internal', (app) => app
          .onBeforeHandle(({ headers, set }) => {
              const internalSecret = process.env.INTERNAL_API_SECRET;
              if (!internalSecret) {
                  console.error('INTERNAL_API_SECRET is not set. Internal API is disabled.');
                  set.status = 503;
                  return { error: 'Service Unavailable' };
              }
              if (headers['x-internal-secret'] !== internalSecret) {
                  set.status = 401;
                  return { error: 'Unauthorized' };
              }
          })
          .get('/state/:instanceId', async ({ params }) => {
              const instanceId = parseInt(params.instanceId, 10);
              const states = await db.select({
                  key: schema.instanceState.key,
                  value: schema.instanceState.value
              }).from(schema.instanceState).where(eq(schema.instanceState.instanceId, instanceId));

              return states;
          })
          .get('/state/:instanceId/:key', async ({ params, set }) => {
              const instanceId = parseInt(params.instanceId, 10);
              const [state] = await db.select({
                  value: schema.instanceState.value
              }).from(schema.instanceState).where(and(
                  eq(schema.instanceState.instanceId, instanceId),
                  eq(schema.instanceState.key, params.key)
              ));

              if (!state) {
                  set.status = 404;
                  return { error: 'State key not found' };
              }
              return state.value; // Return raw value
          })
          .post('/state/:instanceId', async ({ params, body, set }) => {
              const instanceId = parseInt(params.instanceId, 10);
              const { key, value } = body;
              const valueAsBuffer = Buffer.from(value);

              await db.insert(schema.instanceState)
                  .values({ instanceId, key, value: valueAsBuffer })
                  .onConflictDoUpdate({
                      target: [schema.instanceState.instanceId, schema.instanceState.key],
                      set: { value: valueAsBuffer }
                  });

              set.status = 204;
          }, {
              body: t.Object({
                  key: t.String(),
                  value: t.String(),
              })
          })
          .delete('/state/:instanceId/:key', async ({ params, set }) => {
              const instanceId = parseInt(params.instanceId, 10);
              const result = await db.delete(schema.instanceState).where(and(
                  eq(schema.instanceState.instanceId, instanceId),
                  eq(schema.instanceState.key, params.key)
              )).returning();

              if (result.length === 0) {
                  set.status = 404;
                  return { error: 'State key not found' };
              }

              set.status = 204;
          })
          .get('/state/:instanceId/snapshot', async ({ params, set }) => {
              const instanceId = parseInt(params.instanceId, 10);
              const [state] = await db.select({
                  value: schema.instanceState.value
              }).from(schema.instanceState).where(and(
                  eq(schema.instanceState.instanceId, instanceId),
                  eq(schema.instanceState.key, 'session_snapshot')
              ));

              if (!state || !state.value) {
                  set.status = 404;
                  return { error: 'Snapshot not found' };
              }
              // The value is a buffer from the bytea column
              set.headers['Content-Type'] = 'application/octet-stream';
              return state.value;
          })
          .post('/state/:instanceId/snapshot', async ({ params, body, set }) => {
              const instanceId = parseInt(params.instanceId, 10);

              // Body is an ArrayBuffer, convert it to a Buffer for the DB driver
              const value = Buffer.from(body);

              await db.insert(schema.instanceState)
                  .values({ instanceId: instanceId, key: 'session_snapshot', value })
                  .onConflictDoUpdate({
                      target: [schema.instanceState.instanceId, schema.instanceState.key],
                      set: { value }
                  });

              set.status = 204;
          }, { body: t.ArrayBuffer() })
        );
    }
approved: true
linesAdded: 231
linesRemoved: 0
linesDifference: 231
gitCommittedAt: null
status: committed
id: 26
