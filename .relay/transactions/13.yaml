uuid: 440fc7a5-c266-4c40-a15d-85e888e9bb2e
projectId: whatsapp-gateway-saas
createdAt: '2025-11-18T00:55:53.912Z'
gitCommitMsg: >-
  feat: Architect for multi-node distributed deployment

  This commit fundamentally refactors the application architecture to support a
  true multi-VPS, distributed model as envisioned in the project README.

  Key Changes: - **Multi-Node Orchestration**:
    - The database schema is updated with a `nodes` table to register worker VPS nodes.
    - Instances are now associated with a specific node.
    - The `DockerService` is rewritten to act as a remote orchestrator, connecting to the Docker daemons on different nodes to manage containers.

  - **Distributed Networking with Traefik**:
    - A `docker-compose.worker.yml` is added to standardize worker node setup with a Traefik reverse proxy.
    - The gateway now automatically adds Traefik labels to new containers, enabling secure, public-facing ingress without exposing container ports.

  - **Public Proxying & API Refactor**:
    - The gateway API is updated to proxy requests to instances via their public, Traefik-managed URLs instead of internal Docker IPs.
    - Instance creation, deletion, and migration logic is updated to be node-aware.

  - **Binary State Hardening**:
    - The session snapshot mechanism is improved to store raw binary data in a `bytea` column, removing inefficient base64 encoding and enhancing data integrity for migrations.
promptSummary: >-
  The user wants to execute all parts of the plan to refactor the architecture
  for multi-VPS support.
reasoning:
  - >-
    This is a comprehensive update to re-architect the application for a true
    multi-VPS, distributed deployment, fulfilling the core vision of the
    project.
  - '### Part 1: Multi-Node Orchestration'
  - >-
    First, I'll update the database schema to support multiple worker nodes. A
    new `nodes` table is added to store connection details for each VPS, and the
    `instances` table is linked to it, making the system location-aware.
  - '### Part 2: Distributed Networking'
  - >-
    To manage traffic securely across multiple VPS nodes without exposing
    container ports, I am introducing a reverse proxy setup for each worker node
    using Traefik. This `docker-compose.worker.yml` file should be deployed on
    each worker VPS.
  - >-
    Next, I'll completely refactor the `docker.service.ts`. It will no longer
    manage a single, local Docker daemon. Instead, it will become a
    remote-capable orchestrator that connects to the appropriate worker node's
    Docker daemon to manage container lifecycles. It also adds the necessary
    Traefik labels to new containers for automatic service discovery by the
    reverse proxy.
  - '### Part 3 & 4: API Refactor and State Hardening'
  - >-
    Finally, I'll update the main gateway API (`index.ts`). This is a major
    change that accomplishes two goals:
  - >-
    1.  **Public Proxying**: All interactions with provider containers (like
    fetching a QR code or sending a message) are now proxied through the worker
    node's public-facing Traefik endpoint, rather than a private Docker IP. This
    is essential for a distributed system.
  - >-
    2.  **Binary State**: The session snapshotting mechanism is hardened to use
    a proper `bytea` database column for storing the raw binary data of the
    session file, replacing the inefficient and error-prone base64 encoding.
    This improves performance and data integrity, which is critical for the
    zero-downtime migration feature.
operations:
  - type: write
    path: drizzle/schema.ts
    content: >
      --- drizzle/schema.ts

      +++ drizzle/schema.ts

      @@ -1,5 +1,11 @@

      -import { pgTable, serial, text, varchar, timestamp, integer, uniqueIndex,
      pgEnum, unique } from 'drizzle-orm/pg-core';

      +import { pgTable, serial, text, varchar, timestamp, integer, uniqueIndex,
      pgEnum, unique, customType } from 'drizzle-orm/pg-core';
       import { relations } from 'drizzle-orm';
       
      +export const nodes = pgTable('nodes', {

      +  id: serial('id').primaryKey(),

      +  name: varchar('name', { length: 256 }).notNull().unique(),

      +  dockerHost: text('docker_host').notNull(), // e.g.,
      'tcp://1.2.3.4:2375'

      +  publicHost: text('public_host').notNull(), // e.g., 'vps1.example.com'

      +});

      +
       export const users = pgTable('users', {
         id: serial('id').primaryKey(),
         email: varchar('email', { length: 256 }).notNull().unique(),
      @@ -12,6 +18,7 @@
       
       export const instances = pgTable('instances', {
           id: serial('id').primaryKey(),
      +    nodeId: integer('node_id').notNull().references(() => nodes.id, {
      onDelete: 'restrict' }),
           userId: integer('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
           name: varchar('name', { length: 256 }),
           phoneNumber: varchar('phone_number', { length: 20 }).notNull(),
      @@ -27,10 +34,12 @@
           };
       });
       
      +const bytea = customType<{ data: Buffer }>({ getSQL: () => 'bytea' });

      +
       export const instanceState = pgTable('instance_state', {
           id: serial('id').primaryKey(),
           instanceId: integer('instance_id').notNull().references(() => instances.id, { onDelete: 'cascade' }),
           key: varchar('key', { length: 255 }).notNull(),
      -    value: text('value').notNull(),

      +    value: bytea('value').notNull(),
       }, (table) => {
           return {
               instanceKeyIdx: unique('instance_key_idx').on(table.instanceId, table.key),
      @@ -43,6 +52,10 @@
       
       export const instanceRelations = relations(instances, ({ one, many }) => ({
         user: one(users, {
           fields: [instances.userId],
           references: [users.id],
         }),
      +  node: one(nodes, {

      +    fields: [instances.nodeId],

      +    references: [nodes.id],

      +  }),
         state: many(instanceState),
       }));
       
      @@ -52,3 +65,7 @@
               references: [instances.id],
           }),
       }));
      +

      +export const nodeRelations = relations(nodes, ({ many }) => ({

      +    instances: many(instances),

      +}));
    patchStrategy: standard-diff
  - type: write
    path: docker-compose.worker.yml
    content: |-
      version: "3.9"

      services:
        traefik:
          image: "traefik:v3.0"
          container_name: "traefik"
          restart: unless-stopped
          security_opt:
            - no-new-privileges:true
          command:
            - "--api.insecure=true"
            - "--providers.docker=true"
            - "--providers.docker.exposedbydefault=false"
            - "--entrypoints.web.address=:80"
            - "--entrypoints.websecure.address=:443"
            - "--certificatesresolvers.myresolver.acme.httpchallenge=true"
            - "--certificatesresolvers.myresolver.acme.httpchallenge.entrypoint=web"
            - "--certificatesresolvers.myresolver.acme.email=${ACME_EMAIL:-your-email@example.com}" # Change this!
            - "--certificatesresolvers.myresolver.acme.storage=/letsencrypt/acme.json"
          ports:
            - "80:80"
            - "443:443"
            # - "8080:8080" # Traefik Dashboard - uncomment if you need it, but be careful exposing it.
          volumes:
            - "/var/run/docker.sock:/var/run/docker.sock:ro"
            - "./letsencrypt:/letsencrypt"
          networks:
            - worker-net

      networks:
        worker-net:
          driver: bridge
    patchStrategy: replace
  - type: write
    path: gateway/src/docker.service.ts
    content: >-
      import Dockerode from 'dockerode';

      import { URL } from 'url';


      // A simple representation of a worker node, passed from the API layer.

      export interface WorkerNode {
          id: number;
          dockerHost: string;
          publicHost: string;
      }


      function getDockerClientForNode(node: Pick<WorkerNode, 'dockerHost'>):
      Dockerode {
          if (node.dockerHost.startsWith('unix://') || node.dockerHost.startsWith('/')) {
              return new Dockerode({ socketPath: node.dockerHost.replace('unix://', '') });
          }
          if (node.dockerHost.startsWith('tcp://')) {
              const parsedUrl = new URL(node.dockerHost);
              return new Dockerode({ host: parsedUrl.hostname, port: parsedUrl.port });
          }
          // Fallback for simple host:port
          const [host, port] = node.dockerHost.split(':');
          return new Dockerode({ host, port: parseInt(port, 10) });
      }


      function getImageForProvider(provider: string): string {
          const imageMap: Record<string, string> = {
              'whatsmeow': 'jelipro/whatsapp-gateway-whatsmeow:latest',
              // 'baileys': 'some-other-image:latest',
          };
          const image = imageMap[provider];
          if (!image) {
              throw new Error(`Unsupported provider: ${provider}`);
          }
          return image;
      }


      interface CreateContainerOptions {
          instanceId: number;
          node: WorkerNode;
          name?: string | null;
          webhookUrl: string;
          cpuLimit: string;
          memoryLimit: string;
          provider: string;
      }


      function sanitizeForContainerName(name: string): string {
          if (!name) return '';
          return name.toLowerCase().replace(/[^a-z0-9_.-]/g, '-').replace(/-+/g, '-');
      }


      export async function createAndStartContainer(options:
      CreateContainerOptions) {
          const docker = getDockerClientForNode(options.node);
          const saneName = sanitizeForContainerName(options.name || '');
          const containerName = options.name 
              ? `wgs-${options.instanceId}-${saneName}`
              : `wgs-instance-${options.instanceId}`;

          const routerName = `wgs-instance-${options.instanceId}`;

          console.log(`Creating container ${containerName} for instance ${options.instanceId} on node ${options.node.publicHost}`);

          const DOCKER_IMAGE = getImageForProvider(options.provider);

          // 1. Pull the image on the target node
          await pullImage(DOCKER_IMAGE, options.node);

          const gatewayUrl = process.env.GATEWAY_URL; // Should be reachable from worker nodes
          const internalApiSecret = process.env.INTERNAL_API_SECRET;

          // 2. Create the container
          const container = await docker.createContainer({
              Image: DOCKER_IMAGE,
              name: containerName,
              Env: [
                  `INSTANCE_ID=${options.instanceId}`,
                  `GATEWAY_URL=${gatewayUrl}`,
                  `INTERNAL_API_SECRET=${internalApiSecret}`,
                  `WEBHOOK_URL=${options.webhookUrl}`,
                  `PORT=8080`,
                  `GOMAXPROCS=1`
              ],
              Labels: {
                  'whatsapp-gateway-saas.instance-id': String(options.instanceId),
                  // Traefik Labels for reverse proxying
                  'traefik.enable': 'true',
                  [`traefik.http.routers.${routerName}.rule`]: `Host(\`${options.node.publicHost}\`) && PathPrefix(\`/instances/${options.instanceId}\`)`,
                  [`traefik.http.routers.${routerName}.entrypoints`]: 'websecure',
                  [`traefik.http.routers.${routerName}.tls.certresolver`]: 'myresolver',
                  [`traefik.http.services.${routerName}.loadbalancer.server.port`]: '8080',
                  // Middleware to strip the prefix, so /instances/123/qr becomes /qr for the container
                  [`traefik.http.middlewares.${routerName}-stripprefix.stripprefix.prefixes`]: `/instances/${options.instanceId}`,
                  [`traefik.http.routers.${routerName}.middlewares`]: `${routerName}-stripprefix`,
              },
              HostConfig: {
                  RestartPolicy: { Name: 'unless-stopped' },
                  Memory: parseMemory(options.memoryLimit), 
                  NanoCpus: parseFloat(options.cpuLimit || '0') * 1e9,
                  NetworkMode: 'worker-net', // Connect to the shared traefik network
              },
          });

          // 3. Start the container
          await container.start();
          console.log(`Container started with ID: ${container.id}`);

          return container.inspect();
      }


      export async function stopAndRemoveContainer(instanceId: number, node:
      WorkerNode) {
          const docker = getDockerClientForNode(node);
          try {
              const container = await findContainer(instanceId, node);
              if (!container) {
                  console.log(`Container for instance ${instanceId} on node ${node.dockerHost} not found, nothing to do.`);
                  return;
              }

              console.log(`Stopping and removing container ${container.Id} for instance ${instanceId}`);
              const containerInstance = docker.getContainer(container.Id);
              
              // Stop with a 10-second timeout to allow graceful shutdown
              await containerInstance.stop({ t: 10 }).catch(err => {
                  // Ignore "container already stopped" or "no such container" errors
                  if (err.statusCode !== 304 && err.statusCode !== 404) throw err;
              });

              await containerInstance.remove().catch(err => {
                   // Ignore "no such container" errors
                  if (err.statusCode !== 404) throw err;
              });
              console.log(`Container for instance ${instanceId} removed successfully.`);
          } catch (error: any) {
              if (error.statusCode === 404) {
                   console.log(`Container for instance ${instanceId} on node ${node.dockerHost} not found, nothing to do.`);
                   return;
              }
              console.error(`Error stopping/removing container for instance ${instanceId} on node ${node.dockerHost}:`, error);
              throw error;
          }
      }


      export async function findContainer(instanceId: number, node: WorkerNode):
      Promise<Dockerode.ContainerInfo | null> {
          const docker = getDockerClientForNode(node);
          try {
              const containers = await docker.listContainers({
                  all: true,
                  filters: {
                      label: [`whatsapp-gateway-saas.instance-id=${instanceId}`]
                  }
              });

              if (containers.length === 0) {
                  return null;
              }
              if (containers.length > 1) {
                  console.warn(`Found multiple containers for instance ${instanceId} on node ${node.dockerHost}. Using the first one.`);
              }
              return containers[0];
          } catch (error) {
              console.error(`Error finding container for instance ${instanceId} on node ${node.dockerHost}:`, error);
              return null;
          }
      }


      async function pullImage(imageName: string, node: WorkerNode):
      Promise<void> {
          const docker = getDockerClientForNode(node);
          console.log(`Ensuring image ${imageName} is available on node ${node.dockerHost}...`);
          try {
              const images = await docker.listImages({ filters: { reference: [imageName] } });
              if (images.length > 0) {
                  console.log(`Image ${imageName} already exists on node.`);
                  return;
              }

              console.log(`Pulling image ${imageName} on node ${node.dockerHost}...`);
              const pullStream = await docker.pull(imageName);
              
              await new Promise<void>((resolve, reject) => {
                  docker.modem.followProgress(pullStream, (err, _res) => err ? reject(err) : resolve());
              });

              console.log(`Image ${imageName} pulled successfully on node.`);
          } catch (error) {
              console.error(`Failed to pull image ${imageName} on node ${node.dockerHost}:`, error);
              throw error;
          }
      }


      function parseMemory(memoryStr: string): number {
          if (!memoryStr) return 0; // default
          const unit = memoryStr.slice(-1).toLowerCase();
          const value = parseFloat(memoryStr.slice(0, -1));

          if (isNaN(value)) return 0;

          switch (unit) {
              case 'g': return value * 1024 * 1024 * 1024;
              case 'm': return value * 1024 * 1024;
              case 'k': return value * 1024;
              default: return parseFloat(memoryStr); // Assume bytes if no unit
          }
      }
    patchStrategy: replace
  - type: write
    path: gateway/src/index.ts
    content: >-
      import { Elysia, t } from 'elysia';

      import { drizzle } from 'drizzle-orm/postgres-js';

      import { eq, and, not } from 'drizzle-orm';

      import postgres from 'postgres';

      import * as schema from '../../drizzle/schema';

      import { createAndStartContainer, stopAndRemoveContainer, type WorkerNode
      } from './docker.service';


      const connectionString = process.env.DATABASE_URL;

      if (!connectionString) {
        throw new Error("DATABASE_URL is not set");
      }


      const client = postgres(connectionString);

      const db = drizzle(client, { schema });


      // A simple proxy to fetch data from an instance via its public URL

      async function proxyToInstance(instanceUrl: string, options?: RequestInit)
      {
          try {
              const response = await fetch(instanceUrl, options);
              return response;
          } catch (e) {
              console.error(`Failed to proxy request to ${instanceUrl}`, e);
              return null;
          }
      }



      const app = new Elysia()
        .get('/', () => ({ status: 'ok' }))
        .group('/api', (app) => app
          // Resolve user from API Key
          .resolve(async ({ headers }) => {
              const auth = headers['authorization'];
              if (!auth || !auth.startsWith('Bearer ')) {
                  return { user: null };
              }
              const apiKey = auth.substring(7);
              if (!apiKey) {
                  return { user: null };
              }
              const [user] = await db.select().from(schema.users).where(eq(schema.users.apiKey, apiKey));
              
              return { user: user || null };
          })
          // Simple bearer token auth
          .onBeforeHandle(({ user, set }) => {
              if (!user) {
                  set.status = 401;
                  return { error: 'Unauthorized' };
              }
          })
          .post('/instances', async ({ body, set, user }) => {
              // Select a node for the new instance. Simple round-robin or first-available logic.
              // For now, just pick the first one.
              const [node] = await db.select().from(schema.nodes).limit(1);
              if (!node) {
                  set.status = 503;
                  return { error: 'No available worker nodes to schedule instance.' };
              }

              // user is guaranteed to be non-null by the onBeforeHandle guard.
              const [newInstance] = await db.insert(schema.instances).values({
                  nodeId: node.id,
                  userId: user!.id, 
                  name: body.name,
                  phoneNumber: body.phone,
                  provider: body.provider,
                  webhookUrl: body.webhook,
                  cpuLimit: body.resources?.cpu,
                  memoryLimit: body.resources?.memory,
                  status: 'creating',
              }).returning();

              if (!newInstance) {
                  set.status = 500;
                  return { error: 'Failed to create instance in database' };
              }

              try {
                  await createAndStartContainer({
                      instanceId: newInstance.id,
                      node: node,
                      name: newInstance.name,
                      webhookUrl: newInstance.webhookUrl || '',
                      cpuLimit: newInstance.cpuLimit || '0.5',
                      memoryLimit: newInstance.memoryLimit || '512m',
                      provider: newInstance.provider,
                  });
                  const [updatedInstance] = await db.update(schema.instances)
                      .set({ status: 'running' })
                      .where(eq(schema.instances.id, newInstance.id))
                      .returning();
                  return updatedInstance;
              } catch (error) {
                  console.error('Failed to start container:', error);
                  await db.update(schema.instances)
                      .set({ status: 'error' })
                      .where(eq(schema.instances.id, newInstance.id));
                  set.status = 500;
                  return { error: 'Failed to start container for instance' };
              }
          }, {
              body: t.Object({
                  name: t.Optional(t.String()),
                  phone: t.String(),
                  provider: t.Union([
                      t.Literal('whatsmeow'),
                      t.Literal('baileys'),
                      t.Literal('wawebjs'),
                      t.Literal('waba')
                  ]),
                  webhook: t.Optional(t.String()),
                  resources: t.Optional(t.Object({
                      cpu: t.String(),
                      memory: t.String(),
                  }))
              })
          })
          .get('/instances/:id/qr', async ({ params, set, user }) => {
              const instanceId = parseInt(params.id, 10);

              // Ownership check and fetch instance with its node
              const [instanceData] = await db.select().from(schema.instances).where(and(eq(schema.instances.id, instanceId), eq(schema.instances.userId, user!.id))).leftJoin(schema.nodes, eq(schema.instances.nodeId, schema.nodes.id));

              if (!instanceData || !instanceData.instances) {
                  set.status = 404;
                  return { error: 'Instance not found' };
              }
              if (!instanceData.nodes) {
                  set.status = 500;
                  return { error: 'Instance is not associated with a node.' };
              }

              const instanceUrl = `https://${instanceData.nodes.publicHost}/instances/${instanceId}/qr`;
              const qrResponse = await proxyToInstance(instanceUrl);
              if (!qrResponse) {
                  set.status = 503;
                  return { error: "Failed to connect to instance container." };
              }
              if (!qrResponse.ok) {
                  set.status = qrResponse.status;
                  return qrResponse.body;
              }
              
              // The whatsmeow provider returns a PNG. We need to proxy that correctly.
              set.headers['Content-Type'] = qrResponse.headers.get('Content-Type') || 'image/png';
              return qrResponse.blob();
          })
          .post('/instances/:id/send', async ({ params, body, set, user }) => {
              const instanceId = parseInt(params.id, 10);

              // Ownership check
              const [instanceData] = await db.select().from(schema.instances).where(and(eq(schema.instances.id, instanceId), eq(schema.instances.userId, user!.id))).leftJoin(schema.nodes, eq(schema.instances.nodeId, schema.nodes.id));
              if (!instanceData || !instanceData.instances) {
                  set.status = 404;
                  return { error: 'Instance not found' };
              }
              if (!instanceData.nodes) {
                  set.status = 500;
                  return { error: 'Instance is not associated with a node.' };
              }

              const instanceUrl = `https://${instanceData.nodes.publicHost}/instances/${instanceId}/send`;

              const sendResponse = await proxyToInstance(instanceUrl, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify(body)
              });

              if (!sendResponse) {
                  set.status = 503;
                  return { error: "Failed to connect to instance container." };
              }
              set.status = sendResponse.status;
              return await sendResponse.json();
          }, {
              body: t.Object({
                  to: t.String(),
                  text: t.String(),
              })
          })
          .delete('/instances/:id', async ({ params, set, user }) => {
              const instanceId = parseInt(params.id, 10);

              // Ownership check
              const [instanceData] = await db.select().from(schema.instances).where(and(eq(schema.instances.id, instanceId), eq(schema.instances.userId, user!.id))).leftJoin(schema.nodes, eq(schema.instances.nodeId, schema.nodes.id));
              if (!instanceData || !instanceData.instances) {
                  set.status = 404;
                  return { error: 'Instance not found' };
              }
              if (!instanceData.nodes) {
                  // Instance exists but node doesn't. Clean up DB record.
                  await db.delete(schema.instances).where(eq(schema.instances.id, instanceId));
                  return { message: 'Instance found without a node. Record cleaned up.' };
              }

              try {
                  await stopAndRemoveContainer(instanceId, instanceData.nodes);
                  await db.delete(schema.instances).where(eq(schema.instances.id, instanceId));
                  set.status = 204;
              } catch (error) {
                  console.error('Failed to delete instance:', error);
                  set.status = 500;
                  return { error: 'Failed to delete instance' };
              }
          })
          .post('/instances/:id/migrate', async ({ params, set, user, body }) => {
              // The `target_node` from the README is ignored in this single-node implementation.
              const instanceId = parseInt(params.id, 10);

              // 1. Ownership check
              const [instanceData] = await db.select().from(schema.instances).where(and(eq(schema.instances.id, instanceId), eq(schema.instances.userId, user!.id))).leftJoin(schema.nodes, eq(schema.instances.nodeId, schema.nodes.id));
              if (!instanceData || !instanceData.instances || !instanceData.nodes) {
                  set.status = 404;
                  return { error: 'Instance not found or you do not have permission to access it' };
              }
              
              const instance = instanceData.instances;
              const currentNode = instanceData.nodes;

              // Find a new node to migrate to
              const [newNode] = await db.select().from(schema.nodes).where(not(eq(schema.nodes.id, currentNode.id))).limit(1);
              if (!newNode) {
                  set.status = 503;
                  return { error: 'No available node to migrate to.' };
              }

              console.log(`Starting migration for instance ${instanceId} from node ${currentNode.name} to ${newNode.name}`);

              try {
                  // 2. Set status to 'migrating'
                  await db.update(schema.instances).set({ status: 'migrating' }).where(eq(schema.instances.id, instanceId));

                  // 3. Stop and remove the old container. This triggers the snapshot upload on the provider.
                  await stopAndRemoveContainer(instanceId, currentNode);
                  console.log(`Old container for instance ${instanceId} removed from node ${currentNode.name}.`);

                  // 4. Create and start a new container. The provider will fetch the snapshot on startup.
                  await createAndStartContainer({
                      instanceId: instance.id,
                      node: newNode,
                      name: instance.name,
                      webhookUrl: instance.webhookUrl || '',
                      cpuLimit: instance.cpuLimit || '0.5',
                      memoryLimit: instance.memoryLimit || '512m',
                      provider: instance.provider,
                  });
                  console.log(`New container for instance ${instanceId} started on node ${newNode.name}.`);

                  // 5. Set status back to 'running'
                  const [updatedInstance] = await db.update(schema.instances).set({
                      status: 'running',
                      nodeId: newNode.id,
                  })
                      .where(eq(schema.instances.id, instanceId))
                      .returning();
                  
                  console.log(`Migration for instance ${instanceId} completed successfully.`);
                  return { status: 'ok', instance: updatedInstance };
              } catch (error) {
                  console.error(`Migration failed for instance ${instanceId}:`, error);
                  await db.update(schema.instances).set({ status: 'error' }).where(eq(schema.instances.id, instanceId));
                  set.status = 500;
                  return { error: 'Migration failed' };
              }
          }, {
              body: t.Object({
                  target_node: t.Optional(t.String()),
              })
          })
        )
        // New internal API group for state management
        .group('/internal', (app) => app
          .onBeforeHandle(({ headers, set }) => {
              const internalSecret = process.env.INTERNAL_API_SECRET;
              if (!internalSecret) {
                  console.error('INTERNAL_API_SECRET is not set. Internal API is disabled.');
                  set.status = 503;
                  return { error: 'Service Unavailable' };
              }
              if (headers['x-internal-secret'] !== internalSecret) {
                  set.status = 401;
                  return { error: 'Unauthorized' };
              }
          })
          .get('/state/:instanceId', async ({ params }) => {
              const instanceId = parseInt(params.instanceId, 10);
              const states = await db.select({
                  key: schema.instanceState.key,
                  value: schema.instanceState.value
              }).from(schema.instanceState).where(eq(schema.instanceState.instanceId, instanceId));
              
              return states;
          })
          .get('/state/:instanceId/:key', async ({ params, set }) => {
              const instanceId = parseInt(params.instanceId, 10);
              const [state] = await db.select({
                  value: schema.instanceState.value
              }).from(schema.instanceState).where(and(
                  eq(schema.instanceState.instanceId, instanceId),
                  eq(schema.instanceState.key, params.key)
              ));

              if (!state) {
                  set.status = 404;
                  return { error: 'State key not found' };
              }
              return state.value; // Return raw value
          })
          .post('/state/:instanceId', async ({ params, body, set }) => {
              const instanceId = parseInt(params.instanceId, 10);
              const { key, value } = body;
              
              await db.insert(schema.instanceState)
                  .values({ instanceId, key, value })
                  .onConflictDoUpdate({
                      target: [schema.instanceState.instanceId, schema.instanceState.key],
                      set: { value: value }
                  });
              
              set.status = 204;
          }, {
              body: t.Object({
                  key: t.String(),
                  value: t.String(),
              })
          })
          .delete('/state/:instanceId/:key', async ({ params, set }) => {
              const instanceId = parseInt(params.instanceId, 10);
              const result = await db.delete(schema.instanceState).where(and(
                  eq(schema.instanceState.instanceId, instanceId),
                  eq(schema.instanceState.key, params.key)
              )).returning();

              if (result.length === 0) {
                  set.status = 404;
                  return { error: 'State key not found' };
              }
              
              set.status = 204;
          })
          .get('/state/:instanceId/snapshot', async ({ params, set }) => {
              const instanceId = parseInt(params.instanceId, 10);
              const [state] = await db.select({
                  value: schema.instanceState.value
              }).from(schema.instanceState).where(and(
                  eq(schema.instanceState.instanceId, instanceId),
                  eq(schema.instanceState.key, 'session_snapshot')
              ));

              if (!state || !state.value) {
                  set.status = 404;
                  return { error: 'Snapshot not found' };
              }
              // The value is a buffer from the bytea column
              set.headers['Content-Type'] = 'application/octet-stream';
              return state.value;
          })
          .post('/state/:instanceId/snapshot', async ({ params, body, set }) => {
              const instanceId = parseInt(params.instanceId, 10);

              // Body is an ArrayBuffer, convert it to a Buffer for the DB driver
              const value = Buffer.from(body);

              await db.insert(schema.instanceState)
                  .values({ instanceId: instanceId, key: 'session_snapshot', value })
                  .onConflictDoUpdate({
                      target: [schema.instanceState.instanceId, schema.instanceState.key],
                      set: { value: value }
                  });

              set.status = 204;
          }, {
              type: 'arrayBuffer', // Elysia will parse the body as ArrayBuffer
          })
        )
        .listen(3000);

      console.log(
        `ðŸ¦Š Gateway is running at ${app.server?.hostname}:${app.server?.port}`
      );
    patchStrategy: replace
snapshot:
  docker-compose.worker.yml: null
  drizzle/schema.ts: >-
    import { pgTable, serial, text, varchar, timestamp, integer, uniqueIndex,
    pgEnum, unique } from 'drizzle-orm/pg-core';

    import { relations } from 'drizzle-orm';


    export const users = pgTable('users', {
      id: serial('id').primaryKey(),
      email: varchar('email', { length: 256 }).notNull().unique(),
      apiKey: text('api_key').notNull().unique(),
      createdAt: timestamp('created_at').defaultNow().notNull(),
    });


    export const providerEnum = pgEnum('provider', ['whatsmeow', 'baileys',
    'wawebjs', 'waba']);

    export const instanceStatusEnum = pgEnum('status', ['creating', 'starting',
    'running', 'stopped', 'error', 'migrating']);


    export const instances = pgTable('instances', {
        id: serial('id').primaryKey(),
        userId: integer('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
        name: varchar('name', { length: 256 }),
        phoneNumber: varchar('phone_number', { length: 20 }).notNull(),
        provider: providerEnum('provider').notNull(),
        webhookUrl: text('webhook_url'),
        status: instanceStatusEnum('status').default('creating').notNull(),
        cpuLimit: varchar('cpu_limit', { length: 10 }).default('0.5'), // e.g., "0.5"
        memoryLimit: varchar('memory_limit', { length: 10 }).default('512m'), // e.g., "512m"
        createdAt: timestamp('created_at').defaultNow().notNull(),
      }, (table) => {
        return {
          userPhoneIdx: uniqueIndex('user_phone_idx').on(table.userId, table.phoneNumber),
        };
    });


    export const instanceState = pgTable('instance_state', {
        id: serial('id').primaryKey(),
        instanceId: integer('instance_id').notNull().references(() => instances.id, { onDelete: 'cascade' }),
        key: varchar('key', { length: 255 }).notNull(),
        value: text('value').notNull(),
    }, (table) => {
        return {
            instanceKeyIdx: unique('instance_key_idx').on(table.instanceId, table.key),
        };
    });


    export const userRelations = relations(users, ({ many }) => ({
      instances: many(instances),
    }));


    export const instanceRelations = relations(instances, ({ one, many }) => ({
      user: one(users, {
        fields: [instances.userId],
        references: [users.id],
      }),
      state: many(instanceState),
    }));


    export const instanceStateRelations = relations(instanceState, ({ one }) =>
    ({
        instance: one(instances, {
            fields: [instanceState.instanceId],
            references: [instances.id],
        }),
    }));
  gateway/src/docker.service.ts: >-
    import Dockerode from 'dockerode';


    export const docker = new Dockerode(); // Assumes DOCKER_HOST or default
    socket path is configured


    function getImageForProvider(provider: string): string {
        const imageMap: Record<string, string> = {
            'whatsmeow': 'jelipro/whatsapp-gateway-whatsmeow:latest',
            // 'baileys': 'some-other-image:latest',
        };
        const image = imageMap[provider];
        if (!image) {
            throw new Error(`Unsupported provider: ${provider}`);
        }
        return image;
    }


    interface CreateContainerOptions {
        instanceId: number;
        name?: string | null;
        webhookUrl: string;
        cpuLimit: string;
        memoryLimit: string;
        provider: string;
    }


    function sanitizeForContainerName(name: string): string {
        if (!name) return '';
        return name.toLowerCase().replace(/[^a-z0-9_.-]/g, '-').replace(/-+/g, '-');
    }


    export async function createAndStartContainer(options:
    CreateContainerOptions) {
        const saneName = sanitizeForContainerName(options.name || '');
        const containerName = options.name 
            ? `wgs-${options.instanceId}-${saneName}`
            : `wgs-instance-${options.instanceId}`;

        console.log(`Creating container ${containerName} for instance ${options.instanceId}`);

        const DOCKER_IMAGE = getImageForProvider(options.provider);

        // 1. Pull the image
        await pullImage(DOCKER_IMAGE);

        const gatewayUrl = process.env.GATEWAY_URL || 'http://host.docker.internal:3000';
        const internalApiSecret = process.env.INTERNAL_API_SECRET;

        // 2. Create the container
        const container = await docker.createContainer({
            Image: DOCKER_IMAGE,
            name: containerName,
            Env: [
                `INSTANCE_ID=${options.instanceId}`,
                `GATEWAY_URL=${gatewayUrl}`,
                `INTERNAL_API_SECRET=${internalApiSecret}`,
                `WEBHOOK_URL=${options.webhookUrl}`,
                `PORT=8080`,
                `GOMAXPROCS=1`
            ],
            Labels: {
                'whatsapp-gateway-saas.instance-id': String(options.instanceId),
            },
            HostConfig: {
                RestartPolicy: { Name: 'unless-stopped' },
                Memory: parseMemory(options.memoryLimit), 
                NanoCpus: parseFloat(options.cpuLimit || '0') * 1e9,
            },
        });

        // 3. Start the container
        await container.start();
        console.log(`Container started with ID: ${container.id}`);

        return container.inspect();
    }


    export async function stopAndRemoveContainer(instanceId: number) {
        try {
            const container = await findContainer(instanceId);
            if (!container) {
                console.log(`Container for instance ${instanceId} not found, nothing to do.`);
                return;
            }

            console.log(`Stopping and removing container ${container.Id} for instance ${instanceId}`);
            const containerInstance = docker.getContainer(container.Id);
            
            // Stop with a 10-second timeout to allow graceful shutdown
            await containerInstance.stop({ t: 10 }).catch(err => {
                // Ignore "container already stopped" or "no such container" errors
                if (err.statusCode !== 304 && err.statusCode !== 404) throw err;
            });

            await containerInstance.remove().catch(err => {
                 // Ignore "no such container" errors
                if (err.statusCode !== 404) throw err;
            });
            console.log(`Container for instance ${instanceId} removed successfully.`);
        } catch (error: any) {
            if (error.statusCode === 404) {
                 console.log(`Container for instance ${instanceId} not found, nothing to do.`);
                 return;
            }
            console.error(`Error stopping/removing container for instance ${instanceId}:`, error);
            throw error;
        }
    }


    export async function findContainer(instanceId: number):
    Promise<Dockerode.ContainerInfo | null> {
        try {
            const containers = await docker.listContainers({
                all: true,
                filters: {
                    label: [`whatsapp-gateway-saas.instance-id=${instanceId}`]
                }
            });

            if (containers.length === 0) {
                return null;
            }
            if (containers.length > 1) {
                console.warn(`Found multiple containers for instance ${instanceId}. Using the first one.`);
            }
            return containers[0];
        } catch (error) {
            console.error(`Error finding container for instance ${instanceId}:`, error);
            return null;
        }
    }


    async function pullImage(imageName: string): Promise<void> {
        console.log(`Ensuring image ${imageName} is available...`);
        try {
            const images = await docker.listImages({ filters: { reference: [imageName] } });
            if (images.length > 0) {
                console.log(`Image ${imageName} already exists locally.`);
                return;
            }

            console.log(`Pulling image ${imageName}...`);
            const pullStream = await docker.pull(imageName);
            
            await new Promise<void>((resolve, reject) => {
                docker.modem.followProgress(pullStream, (err, _res) => err ? reject(err) : resolve());
            });

            console.log(`Image ${imageName} pulled successfully.`);
        } catch (error) {
            console.error(`Failed to pull image ${imageName}:`, error);
            throw error;
        }
    }


    function parseMemory(memoryStr: string): number {
        if (!memoryStr) return 0; // default
        const unit = memoryStr.slice(-1).toLowerCase();
        const value = parseFloat(memoryStr.slice(0, -1));

        if (isNaN(value)) return 0;

        switch (unit) {
            case 'g': return value * 1024 * 1024 * 1024;
            case 'm': return value * 1024 * 1024;
            case 'k': return value * 1024;
            default: return parseFloat(memoryStr); // Assume bytes if no unit
        }
    }
  gateway/src/index.ts: >-
    import { Elysia, t } from 'elysia';

    import { drizzle } from 'drizzle-orm/postgres-js';

    import { eq, and } from 'drizzle-orm';

    import postgres from 'postgres';

    import * as schema from '../../drizzle/schema';

    import { createAndStartContainer, findContainer, stopAndRemoveContainer,
    docker } from './docker.service';


    const connectionString = process.env.DATABASE_URL;

    if (!connectionString) {
      throw new Error("DATABASE_URL is not set");
    }


    const client = postgres(connectionString);

    const db = drizzle(client, { schema });


    // A simple proxy to fetch data from a container

    async function proxyToContainer(containerIp: string, path: string, options?:
    RequestInit) {
        const url = `http://${containerIp}:8080${path}`;
        try {
            const response = await fetch(url, options);
            return response;
        } catch (e) {
            console.error(`Failed to proxy request to ${url}`, e);
            return null;
        }
    }



    const app = new Elysia()
      .get('/', () => ({ status: 'ok' }))
      .group('/api', (app) => app
        // Resolve user from API Key
        .resolve(async ({ headers }) => {
            const auth = headers['authorization'];
            if (!auth || !auth.startsWith('Bearer ')) {
                return { user: null };
            }
            const apiKey = auth.substring(7);
            if (!apiKey) {
                return { user: null };
            }
            const [user] = await db.select().from(schema.users).where(eq(schema.users.apiKey, apiKey));
            
            return { user: user || null };
        })
        // Simple bearer token auth
        .onBeforeHandle(({ user, set }) => {
            if (!user) {
                set.status = 401;
                return { error: 'Unauthorized' };
            }
        })
        .post('/instances', async ({ body, set, user }) => {
            // user is guaranteed to be non-null by the onBeforeHandle guard.
            const [newInstance] = await db.insert(schema.instances).values({
                userId: user!.id, 
                name: body.name,
                phoneNumber: body.phone,
                provider: body.provider,
                webhookUrl: body.webhook,
                cpuLimit: body.resources?.cpu,
                memoryLimit: body.resources?.memory,
                status: 'creating',
            }).returning();

            if (!newInstance) {
                set.status = 500;
                return { error: 'Failed to create instance in database' };
            }

            try {
                await createAndStartContainer({
                    instanceId: newInstance.id,
                    name: newInstance.name,
                    webhookUrl: newInstance.webhookUrl || '',
                    cpuLimit: newInstance.cpuLimit || '0.5',
                    memoryLimit: newInstance.memoryLimit || '512m',
                    provider: newInstance.provider,
                });
                const [updatedInstance] = await db.update(schema.instances)
                    .set({ status: 'running' })
                    .where(eq(schema.instances.id, newInstance.id))
                    .returning();
                return updatedInstance;
            } catch (error) {
                console.error('Failed to start container:', error);
                await db.update(schema.instances)
                    .set({ status: 'error' })
                    .where(eq(schema.instances.id, newInstance.id));
                set.status = 500;
                return { error: 'Failed to start container for instance' };
            }
        }, {
            body: t.Object({
                name: t.Optional(t.String()),
                phone: t.String(),
                provider: t.Union([
                    t.Literal('whatsmeow'),
                    t.Literal('baileys'),
                    t.Literal('wawebjs'),
                    t.Literal('waba')
                ]),
                webhook: t.Optional(t.String()),
                resources: t.Optional(t.Object({
                    cpu: t.String(),
                    memory: t.String(),
                }))
            })
        })
        .get('/instances/:id/qr', async ({ params, set, user }) => {
            const instanceId = parseInt(params.id, 10);

            // Ownership check
            const [instance] = await db.select().from(schema.instances).where(eq(schema.instances.id, instanceId));
            if (!instance) {
                set.status = 404;
                return { error: 'Instance not found' };
            }
            if (instance.userId !== user!.id) {
                set.status = 403;
                return { error: 'Forbidden' };
            }
            const container = await findContainer(instanceId);

            if (!container || container.State !== 'running') {
                set.status = 404;
                return { error: 'Instance container not found or not running' };
            }
            
            const containerInfo = await docker.getContainer(container.Id).inspect();
            const ip = containerInfo.NetworkSettings.IPAddress;
            if (!ip) {
                 set.status = 500;
                 return { error: "Could not determine container IP address." };
            }

            const qrResponse = await proxyToContainer(ip, '/qr');
            if (!qrResponse) {
                set.status = 503;
                return { error: "Failed to connect to instance container." };
            }
            if (!qrResponse.ok) {
                set.status = qrResponse.status;
                return { error: `Instance returned an error: ${qrResponse.statusText}`};
            }
            
            // The whatsmeow provider returns a PNG. We need to proxy that correctly.
            set.headers['Content-Type'] = qrResponse.headers.get('Content-Type') || 'image/png';
            return qrResponse.blob();
        })
        .post('/instances/:id/send', async ({ params, body, set, user }) => {
            const instanceId = parseInt(params.id, 10);

            // Ownership check
            const [instance] = await db.select().from(schema.instances).where(eq(schema.instances.id, instanceId));
            if (!instance) {
                set.status = 404;
                return { error: 'Instance not found' };
            }
            if (instance.userId !== user!.id) {
                set.status = 403;
                return { error: 'Forbidden' };
            }
            const container = await findContainer(instanceId);

            if (!container || container.State !== 'running') {
                set.status = 404;
                return { error: 'Instance container not found or not running' };
            }
            const containerInfo = await docker.getContainer(container.Id).inspect();
            const ip = containerInfo.NetworkSettings.IPAddress;
            if (!ip) {
                 set.status = 500;
                 return { error: "Could not determine container IP address." };
            }

            const sendResponse = await proxyToContainer(ip, '/send', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            });

            if (!sendResponse) {
                set.status = 503;
                return { error: "Failed to connect to instance container." };
            }
            set.status = sendResponse.status;
            return await sendResponse.json();
        }, {
            body: t.Object({
                to: t.String(),
                text: t.String(),
            })
        })
        .delete('/instances/:id', async ({ params, set, user }) => {
            const instanceId = parseInt(params.id, 10);

            // Ownership check
            const [instance] = await db.select({ userId: schema.instances.userId }).from(schema.instances).where(eq(schema.instances.id, instanceId));
            if (!instance) {
                set.status = 404;
                return { error: 'Instance not found' };
            }
            if (instance.userId !== user!.id) {
                set.status = 403;
                return { error: 'Forbidden' };
            }

            try {
                await stopAndRemoveContainer(instanceId);
                await db.delete(schema.instances).where(eq(schema.instances.id, instanceId));
                set.status = 204;
            } catch (error) {
                console.error('Failed to delete instance:', error);
                set.status = 500;
                return { error: 'Failed to delete instance' };
            }
        })
        .post('/instances/:id/migrate', async ({ params, set, user, body }) => {
            // The `target_node` from the README is ignored in this single-node implementation.
            const instanceId = parseInt(params.id, 10);

            // 1. Ownership check
            const [instance] = await db.select().from(schema.instances).where(and(eq(schema.instances.id, instanceId), eq(schema.instances.userId, user!.id)));
            if (!instance) {
                set.status = 404;
                return { error: 'Instance not found or you do not have permission to access it' };
            }
            
            console.log(`Starting migration for instance ${instanceId}`);

            try {
                // 2. Set status to 'migrating'
                await db.update(schema.instances).set({ status: 'migrating' }).where(eq(schema.instances.id, instanceId));

                // 3. Stop and remove the old container. This triggers the snapshot upload on the provider.
                await stopAndRemoveContainer(instanceId);
                console.log(`Old container for instance ${instanceId} removed.`);

                // 4. Create and start a new container. The provider will fetch the snapshot on startup.
                await createAndStartContainer({
                    instanceId: instance.id,
                    name: instance.name,
                    webhookUrl: instance.webhookUrl || '',
                    cpuLimit: instance.cpuLimit || '0.5',
                    memoryLimit: instance.memoryLimit || '512m',
                    provider: instance.provider,
                });
                console.log(`New container for instance ${instanceId} started.`);

                // 5. Set status back to 'running'
                const [updatedInstance] = await db.update(schema.instances)
                    .set({ status: 'running' })
                    .where(eq(schema.instances.id, instanceId))
                    .returning();
                
                console.log(`Migration for instance ${instanceId} completed successfully.`);
                return { status: 'ok', instance: updatedInstance };
            } catch (error) {
                console.error(`Migration failed for instance ${instanceId}:`, error);
                await db.update(schema.instances).set({ status: 'error' }).where(eq(schema.instances.id, instanceId));
                set.status = 500;
                return { error: 'Migration failed' };
            }
        }, {
            body: t.Object({
                target_node: t.Optional(t.String()),
            })
        })
      )
      // New internal API group for state management
      .group('/internal', (app) => app
        .onBeforeHandle(({ headers, set }) => {
            const internalSecret = process.env.INTERNAL_API_SECRET;
            if (!internalSecret) {
                console.error('INTERNAL_API_SECRET is not set. Internal API is disabled.');
                set.status = 503;
                return { error: 'Service Unavailable' };
            }
            if (headers['x-internal-secret'] !== internalSecret) {
                set.status = 401;
                return { error: 'Unauthorized' };
            }
        })
        .get('/state/:instanceId', async ({ params }) => {
            const instanceId = parseInt(params.instanceId, 10);
            const states = await db.select({
                key: schema.instanceState.key,
                value: schema.instanceState.value
            }).from(schema.instanceState).where(eq(schema.instanceState.instanceId, instanceId));
            
            return states;
        })
        .get('/state/:instanceId/:key', async ({ params, set }) => {
            const instanceId = parseInt(params.instanceId, 10);
            const [state] = await db.select({
                value: schema.instanceState.value
            }).from(schema.instanceState).where(and(
                eq(schema.instanceState.instanceId, instanceId),
                eq(schema.instanceState.key, params.key)
            ));

            if (!state) {
                set.status = 404;
                return { error: 'State key not found' };
            }
            return state.value; // Return raw value
        })
        .post('/state/:instanceId', async ({ params, body, set }) => {
            const instanceId = parseInt(params.instanceId, 10);
            const { key, value } = body;
            
            await db.insert(schema.instanceState)
                .values({ instanceId, key, value })
                .onConflictDoUpdate({
                    target: [schema.instanceState.instanceId, schema.instanceState.key],
                    set: { value: value }
                });
            
            set.status = 204;
        }, {
            body: t.Object({
                key: t.String(),
                value: t.String(),
            })
        })
        .delete('/state/:instanceId/:key', async ({ params, set }) => {
            const instanceId = parseInt(params.instanceId, 10);
            const result = await db.delete(schema.instanceState).where(and(
                eq(schema.instanceState.instanceId, instanceId),
                eq(schema.instanceState.key, params.key)
            )).returning();

            if (result.length === 0) {
                set.status = 404;
                return { error: 'State key not found' };
            }
            
            set.status = 204;
        })
        .get('/state/:instanceId/snapshot', async ({ params, set }) => {
            const instanceId = parseInt(params.instanceId, 10);
            const [state] = await db.select({
                value: schema.instanceState.value
            }).from(schema.instanceState).where(and(
                eq(schema.instanceState.instanceId, instanceId),
                eq(schema.instanceState.key, 'session_snapshot')
            ));

            if (!state || !state.value) {
                set.status = 404;
                return { error: 'Snapshot not found' };
            }
            // The value is base64 encoded text, decode it and return as binary
            set.headers['Content-Type'] = 'application/octet-stream';
            return Buffer.from(state.value, 'base64');
        })
        .post('/state/:instanceId/snapshot', async ({ params, body, set }) => {
            const instanceId = parseInt(params.instanceId, 10);

            // The body is raw bytes, we need to base64 encode it for storing in text field
            let bodyBuffer: Buffer;
            if (body instanceof ReadableStream) {
                bodyBuffer = await new Response(body).arrayBuffer().then(buf => Buffer.from(buf));
            } else if (Buffer.isBuffer(body)) {
                bodyBuffer = body;
            } else if (typeof body === 'string') {
                bodyBuffer = Buffer.from(body, 'utf-8');
            } else {
                bodyBuffer = Buffer.from(JSON.stringify(body), 'utf-8');
            }
            const value = bodyBuffer.toString('base64');

            await db.insert(schema.instanceState)
                .values({ instanceId, key: 'session_snapshot', value })
                .onConflictDoUpdate({
                    target: [schema.instanceState.instanceId, schema.instanceState.key],
                    set: { value: value }
                });

            set.status = 204;
        }, {
            // Allow any content type as we are reading the raw body
            type: 'none',
            body: t.Any(),
        })
      )
      .listen(3000);

    console.log(
      `ðŸ¦Š Gateway is running at ${app.server?.hostname}:${app.server?.port}`
    );
approved: true
linesAdded: 174
linesRemoved: 98
linesDifference: 272
gitCommittedAt: null
status: committed
id: 13
